{"pages":[{"title":"About me","text":"大部分的程式碼是以 C# 示範，懇請批評與指教，謝謝。","link":"/about/index.html"}],"posts":[{"title":"[Design Pattern] Visitor 模式 (二)","text":"在上一篇介紹了 Visitor 模式，在不常新增衍生類別時，它會是一個好方法。但如果今天要新增一個飛機類別，要在 IVisitor 定義一個新方法及在 Visitor 類別中實作該方法，新增完後會需要將既有的類別重新編譯，很不方便。 Acyclic Visitor Pattern 解決了這個問題，我們可以將 IVisitor 介面退化，讓它不包含任何方法，然後各個類別各自建立自己的介面。 Acyclic Visitor 模式相較於上一篇的 IVisitor，IAcyclicVisitor 沒有包含任何方法，而是各個類別建立各自的介面，如下所示： 1234567891011/*IAcyclicVisitor.cs*/namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// IAcyclicVisitor /// &lt;/summary&gt; public interface IAcyclicVisitor { }} 12345678910111213141516/*IMotorVisitor.cs*/namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// IMotorVisitor /// &lt;/summary&gt; public interface IMotorVisitor : IAcyclicVisitor { /// &lt;summary&gt; /// Visit for Motor /// &lt;/summary&gt; /// &lt;param name=&quot;motor&quot;&gt;&lt;/param&gt; void Visit(AcyclicMotor motor); }} 12345678910111213141516/*IBusVisitor.cs*/namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// IBusVisitor /// &lt;/summary&gt; public interface IBusVisitor : IAcyclicVisitor { /// &lt;summary&gt; /// Visit for Bus /// &lt;/summary&gt; /// &lt;param name=&quot;bus&quot;&gt;&lt;/param&gt; void Visit(AcyclicBus bus); }} 巴士、機車類別的實作跟上一篇差不多，只是在呼叫 Visit 方法前，要先判斷是否為該類別之介面： 12345678910111213141516171819202122232425262728293031/*IAcyclicTransportation.cs*/namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// IAcyclicTransportation /// &lt;/summary&gt; public interface IAcyclicTransportation { /// &lt;summary&gt; /// 馬力 /// &lt;/summary&gt; decimal Power { get; set; } /// &lt;summary&gt; /// 限乘人數 /// &lt;/summary&gt; int NumberOfPassenger { get; set; } /// &lt;summary&gt; /// 是否有冷氣 /// &lt;/summary&gt; bool HasAirConditioner { get; set; } /// &lt;summary&gt; /// Accept /// &lt;/summary&gt; /// &lt;param name=&quot;visitor&quot;&gt;&lt;/param&gt; void Accept(IAcyclicVisitor visitor); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*AcyclicMotor.cs*/namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// 機車 /// &lt;/summary&gt; public class AcyclicMotor : IAcyclicTransportation { /// &lt;summary&gt; /// 馬力 /// &lt;/summary&gt; public decimal Power { get; set; } /// &lt;summary&gt; /// 限乘人數 /// &lt;/summary&gt; public int NumberOfPassenger { get; set; } /// &lt;summary&gt; /// 是否有冷氣 /// &lt;/summary&gt; public bool HasAirConditioner { get; set; } /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;power&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;numberOfPassenger&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hasAirConditioner&quot;&gt;&lt;/param&gt; public AcyclicMotor(decimal power, int numberOfPassenger, bool hasAirConditioner) { this.Power = power; this.NumberOfPassenger = numberOfPassenger; this.HasAirConditioner = hasAirConditioner; } /// &lt;summary&gt; /// Accept /// &lt;/summary&gt; /// &lt;param name=&quot;visitor&quot;&gt;&lt;/param&gt; public void Accept(IAcyclicVisitor visitor) { if (visitor is IMotorVisitor) { (visitor as IMotorVisitor).Visit(this); } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*AcyclicBus.cs*/namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// 巴士 /// &lt;/summary&gt; public class AcyclicBus : IAcyclicTransportation { /// &lt;summary&gt; /// 馬力 /// &lt;/summary&gt; public decimal Power { get; set; } /// &lt;summary&gt; /// 限乘人數 /// &lt;/summary&gt; public int NumberOfPassenger { get; set; } /// &lt;summary&gt; /// 是否有冷氣 /// &lt;/summary&gt; public bool HasAirConditioner { get; set; } /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;power&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;numberOfPassenger&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hasAirConditioner&quot;&gt;&lt;/param&gt; public AcyclicBus(decimal power, int numberOfPassenger, bool hasAirConditioner) { this.Power = power; this.NumberOfPassenger = numberOfPassenger; this.HasAirConditioner = hasAirConditioner; } /// &lt;summary&gt; /// Accept /// &lt;/summary&gt; /// &lt;param name=&quot;visitor&quot;&gt;&lt;/param&gt; public void Accept(IAcyclicVisitor visitor) { if (visitor is IBusVisitor) { (visitor as IBusVisitor).Visit(this); } } }} 最後是實作 AcyclicVisitor 類別，除了要繼承巴士、機車相對應的介面並實作，其他地方跟之前的一樣： 12345678910111213141516171819202122232425262728293031323334353637383940/*AcyclicVisitor.cs*/using System;namespace DemoCode.DesignPattern.Visitor.AcyclicVisitor{ /// &lt;summary&gt; /// AcyclicVisitor /// &lt;/summary&gt; public class AcyclicVisitor : IBusVisitor, IMotorVisitor { /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; public AcyclicVisitor() { } /// &lt;summary&gt; /// Visit for Motor /// &lt;/summary&gt; /// &lt;param name=&quot;motor&quot;&gt;&lt;/param&gt; public void Visit(AcyclicMotor motor) { Console.WriteLine($&quot;這是台機車，我只在意馬力:{motor.Power}&quot;); } /// &lt;summary&gt; /// Visit for Bus /// &lt;/summary&gt; /// &lt;param name=&quot;bus&quot;&gt;&lt;/param&gt; public void Visit(AcyclicBus bus) { var ifHasAirConditioner = bus.HasAirConditioner == true ? &quot;有冷氣&quot; : &quot;沒有冷氣&quot;; Console.WriteLine($&quot;這是台公車，我只在意限乘人數:{bus.NumberOfPassenger},&quot; + $&quot;以及有沒有冷氣:{ifHasAirConditioner}&quot;); } }} 12345678910111213/*Program.cs*/class Program{ static void Main(string[] args) { var bus = new AcyclicBus(1000, 20, true); var motor = new AcyclicMotor(100, 2, false); var visitor = new AcyclicVisitor(); bus.Accept(visitor); motor.Accept(visitor); }} 最後輸出結果如下，跟前一篇結果相同： 12我是台公車，我只在意限乘人數:20,以及有沒有冷氣:有冷氣我是台機車，我只在意馬力:100 完整程式碼請參考 結論Acyclic Visitor 模式將巴士、機車的介面獨立出來，未來若要新增飛機類別，只要新增飛機的介面、類別，以及在 AcyclicVisitor 實作飛機的 Visit 方法即可。 在【無瑕的程式碼】中提到，因為有使用轉型(在巴士、機車類別中的 Accept 方法)，會花費大量的執行時間，所以 Acyclic Visitor 模式不適用於硬即時模式(hard real-time system)。查了一下是什麼意思，將參考附圖於下方。 \b 參考VISITOR 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐16.即時作業系統","link":"/2022/02/03/Acyclic-Visitor-Pattern/"},{"title":"[Design Pattern] Adapter 模式","text":"Wiki 上是這麼定義 Adapter 模式的: 將一個類別的介面轉接成使用者所期待的。一個適配使得因介面不相容而不能在一起工作的類別能在一起工作。 舉個例子，我有養狗，但是我喜歡的女生比較喜歡貓，為了吸引他的注意力，我決定把我的狗假扮成一隻貓。套用到 Adapter 模式，可以想像成是這樣: 我要把我的狗 (Adaptee)，藉由外觀的打扮 (Adapter)，變成一隻貓 (Target) 看看自己的狗先來看我們既有的狗類別，以及他既有的方法。 Dog.cs123456789101112131415161718/*Dog.cs*/using System;namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// Dog /// &lt;/summary&gt; public class Dog { /// &lt;summary&gt; /// 狗叫 /// &lt;/summary&gt; public void Bark() { Console.WriteLine(&quot;I'm a dog, bark&quot;); } }} 看看要假扮的貓再來定義貓的介面，要求不多，只要我的狗會學貓叫即可。 ICat.cs1234567891011121314/*ICat.cs*/namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// ICat /// &lt;/summary&gt; public interface ICat { /// &lt;summary&gt; /// 貓叫 /// &lt;/summary&gt; void Meow(); }} Adapter 模式先定義一個類別 CatAdapter ，其會繼承介面 ICat 並需要實作 ICat 的方法 。建構子參數為我們既有的狗類別。現在要實作方法 Meow()，實作內容我們使用 Dog 類別的方法 Bark()，讓人以為狗叫是貓叫。(現實中是有點強人所難…) CatAdapter.cs1234567891011121314151617181920212223242526272829/*CatAdapter.cs*/namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// CatAdapter /// &lt;/summary&gt; public class CatAdapter : ICat { /// &lt;summary&gt; /// Dog /// &lt;/summary&gt; private Dog _dog; /// &lt;summary&gt; /// CatAdapter /// &lt;/summary&gt; /// &lt;param name=&quot;dog&quot;&gt;&lt;/param&gt; public CatAdapter(Dog dog) { this._dog = dog; } /// &lt;summary&gt; /// 貓叫 /// &lt;/summary&gt; public void Meow() { this._dog.Bark(); } }} 類別形式的 Adapter 模式上一個 Adapter 模式，我們是用建構子注入的方式，將我們的狗類別放進 CatAdapter 類別，另一種方式是直接繼承 Dog 類別，這樣的好處是我只要建立一個 CatAdapterClassType 類別就好，壞處是其造成 Dog 類別與 CatAdapterClassType 類別的強耦合。 CatAdapterClassType.cs12345678910111213141516171819202122/*CatAdapterClassType*/using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// CatAdapterClassType /// &lt;/summary&gt; public class CatAdapterClassType : Dog, ICat { /// &lt;summary&gt; /// 貓叫 /// &lt;/summary&gt; public void Meow() { this.Bark(); } }} 最後來看結果: Program.cs1234567891011class Program{ static void Main(string[] args) { CatAdapter catAdapter = new CatAdapter(new Dog()); catAdapter.Meow(); CatAdapterClassType catAdapterClassType = new CatAdapterClassType(); catAdapterClassType.Meow(); Console.Read(); }} 完整程式碼請參考 結論如果因為介面的改變，造成與既有的系統不相容時，可以使用 Adapter 模式，將其轉換為既有系統可使用的格式。 參考 江湖走跳，轉接頭很重要! (Adapter 適配器模式) Design Pattern: Structural Patterns- Adapter Pattern (適配器模式) Adapter 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/09/04/Adapter-Pattern/"},{"title":"[Design Pattern] Factory 模式","text":"假設我們今天要開一間玩具工廠，工廠生產的玩具有：金剛、哥吉拉，寫法可能像這樣： Program.cs12345678910111213141516171819/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;namespace DemoCode{ class Program { static void Main(string[] args) { IToy toy1 = new Gozilla(); IToy toy2 = new KingKong(); Console.WriteLine($&quot;Toy I made: {toy1.ToyName}&quot;); Console.WriteLine($&quot;Toy I made: {toy2.ToyName}&quot;); } }} IToy.cs123456789/*IToy.cs*/namespace DemoCode.DesignPattern.Factory{ public interface IToy { public string ToyName { get; set; } }} Gozilla.cs1234567891011121314/*Gozilla.cs*/namespace DemoCode.DesignPattern.Factory{ public class Gozilla : IToy { public string ToyName { get; set; } public Gozilla() { ToyName = &quot;Gozilla&quot;; } }} KingKong.cs1234567891011121314/*KingKong.cs*/namespace DemoCode.DesignPattern.Factory{ public class KingKong : IToy { public string ToyName { get; set; } public KingKong() { ToyName = &quot;KingKong&quot;; } }} 架構圖會像是這樣子，我們會在 Program 裡直接建立 KingKong、Gozilla 執行個體，如果這個類別不常變更，其實直接建立是沒有問題的，但如果是在開發階段，我們應當依賴於抽象介面，避免受類別變化帶來的影響。\b\b Factory 模式示範DIP 原則告訴我們：應該優先依賴於抽象類別，避免依賴於實體類別。所以我們新增一個工廠介面 IFactory，以及實作該介面的類別 Factory，藉由這個工廠來幫我們生產玩具： Program.cs123456789101112131415161718192021/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;namespace DemoCode{ class Program { static void Main(string[] args) { IFactory factory = new Factory(); IToy toy1 = factory.Make(&quot;KingKong&quot;); IToy toy2 = factory.Make(&quot;Gozilla&quot;); Console.WriteLine($&quot;Toy I made is: {toy1.ToyName}&quot;); Console.WriteLine($&quot;Toy I made is: {toy2.ToyName}&quot;); } }} IFactory.cs123456789/*IFactory.cs*/namespace DemoCode.DesignPattern.Factory{ public interface IFactory { IToy Make(string toyName); }} Factory.cs123456789101112131415161718192021222324252627/*Factory.cs*/using System;namespace DemoCode.DesignPattern.Factory{ public class Factory : IFactory { public Factory() { } public IToy Make(string toyName) { switch (toyName) { case &quot;Gozilla&quot;: return new Gozilla(); case &quot;KingKong&quot;: return new KingKong(); default: throw new ApplicationException($&quot;沒有生產該玩具: {toyName}&quot;); } } }} 我們在 Program 中建立一個 Factory 的類別實作，並將製作玩具的工作交給 Factory，這樣的話職責就很明確，工廠專職製造玩具，Program 只需直接使用 Factory 所回傳的類別實作。 完整程式碼請參考 結論Factory 模式使得高層模組不依賴於類別的實作，並遵守 DIP 原則，在程式的職責管理上也較為清楚明白。但如果你的類別是不常變更且穩定的，那也不需使用 Factory 模式，直接建立類別實作會省事許多。 參考Factory 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/04/04/Factory-Pattern/"},{"title":"[Design Pattern] Visitor 模式 (三)","text":"Visitor 模式可以再不改變現有類別結構的情況下，像類別結構增加新方法。另一個可以達到相同目的的模式是 Decorator 模式。 想像假設要實作一個方法，乘客要下車時需要按下車鈴通知司機。如果將該方法宣告在介面中，並讓各個類別實作，這樣也不是不行，但是如果之後有更多需求，就會變得需要頻繁異動該類別。 所以可以這樣想：讓有該需求的使用者去呼叫實作該需求的類別即可，即我實作一個「下車按鈴」的類別，讓公車類別來使用，如果交通工具是機車的話就不會使用到該類別。 按鈴下公車123456789101112131415161718192021/*Itransportation.cs*/using System;namespace DemoCode.DesignPattern.Visitor.Decorator{ /// &lt;summary&gt; /// 交通工具 /// &lt;/summary&gt; public interface ITransportation { /// &lt;summary&gt; /// 找座位 /// &lt;/summary&gt; void TakeASeat(); /// &lt;summary&gt; /// 下車 /// &lt;/summary&gt; void TakeOff(); }} 123456789101112131415161718192021222324252627/*Bus.cs*/using System;namespace DemoCode.DesignPattern.Visitor.Decorator{ /// &lt;summary&gt; /// 公車 /// &lt;/summary&gt; public class Bus : ITransportation { /// &lt;summary&gt; /// 找座位 /// &lt;/summary&gt; public void TakeASeat() { Console.WriteLine(&quot;找個座位&quot;); } /// &lt;summary&gt; /// 下車 /// &lt;/summary&gt; public void TakeOff() { Console.WriteLine(&quot;司機先生我要下車&quot;); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142/*RingBeforeTakeOffBus.cs*/using System;namespace DemoCode.DesignPattern.Visitor.Decorator{ /// &lt;summary&gt; /// 下車前需要按鈴 /// &lt;/summary&gt; public class RingBeforeTakeOffBus : ITransportation { /// &lt;summary&gt; /// 交通工具 /// &lt;/summary&gt; private ITransportation itsTransportation; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;transportation&quot;&gt;&lt;/param&gt; public RingBeforeTakeOffBus(ITransportation transportation) { this.itsTransportation = transportation; } /// &lt;summary&gt; /// 找座位 /// &lt;/summary&gt; public void TakeASeat() { itsTransportation.TakeASeat(); } /// &lt;summary&gt; /// 下車 /// &lt;/summary&gt; public void TakeOff() { Console.WriteLine(&quot;按鈴下車&quot;); itsTransportation.TakeOff(); } }} 收攏重複的程式碼如果現在要實作其他的裝飾者類別，例如下車前要刷卡 (BeepBeforeTakeOff)，但是如果照前面的寫法，TakeASeat() 這個方法的程式碼會重複出現於 BipBeforeTakeOff 及 RingBeforeTakeOff 類別，我們可以把會重複的程式碼收攏在一個類別即可。 12345678910111213141516171819202122232425/*BusDecorator.cs*/using System;namespace DemoCode.DesignPattern.Visitor.Decorator{ public class BusDecorator : ITransportation { private ITransportation itsTransportation; public BusDecorator(ITransportation transportation) { this.itsTransportation = transportation; } public void TakeASeat() { itsTransportation.TakeASeat(); } public void TakeOff() { itsTransportation.TakeOff(); } }} 123456789101112131415161718192021/*BeepBeforeTakeOffBus.cs*/using System;namespace DemoCode.DesignPattern.Visitor.Decorator{ public class BeepBeforeTakeOffBus : BusDecorator { private ITransportation itsTransportation; public BeepBeforeTakeOffBus(ITransportation transportation) : base(transportation) { itsTransportation = transportation; } public new void TakeOff() { Console.WriteLine(&quot;下車前刷卡&quot;); itsTransportation.TakeOff(); } }} 輸出結果： 12345678910class Program{ static void Main(string[] args) { var bus = new DemoCode.DesignPattern.Visitor.Decorator.Bus(); var decorator = new DemoCode.DesignPattern.Visitor.Decorator.BeepBeforeTakeOffBus(bus); decorator.TakeOff(); }} 12下車前刷卡司機先生我要下車 完整程式碼請參考 結論裝飾者模式提供了另一種方法，來達到在不改變既有的類別下增加新的方法。裝飾者模式與其他模式的比較可以 參考此篇 參考VISITOR 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐iThome 鐵人競賽 - [Design Pattern] Decorator 裝飾者模式","link":"/2022/03/03/Decorator-Pattern/"},{"title":"[Git] Revert 造成別人的程式被 rollback","text":"有天工作時在 feature branch 開發完，準備發 pull request 回 develop branch，在 review PR 時發現有不是我開發的程式碼，而且在比較 branch diffrence 時，發現我的 pull request 會把別人的程式 rollback，原本想說只要從 develop branch 先發 PR merge 回 feature branch，再把 feature branch merge 回 develop 即可，但情況還是一樣，以為又是 Bitbucket 的 bug，畢竟之前還會在 X PR 看到 Y PR 的內容。 就在苦惱到底為何會這樣時，同事的一句：「你是不是有 revert 啊？」讓我恍然大悟，仔細看我的 commit，發現我當時確實有做過把 「develop branch merge 回 feature branch」，但後來覺得這樣 PR 會包含不止我的程式碼，review 起來會很亂，所以又做 「revert develop branch merge 進 feature branch」，就是這個動作導致後續將 feature branch 要 merge 回 develop branch 時會將別人的 code 給 rollback，commit 的排序如下圖所示： 解法很簡單，在 feature branch 將 「revert develop branch merge 進 feature branch」 的這個 commit 再 revert 一次，然後再從 feature branch 發 PR 回 develop branch 即可。","link":"/2022/05/01/Git-Revert-Cause-Rollback/"},{"title":"[Design Pattern] Observer 模式","text":"訂閱者模式在生活中處處可見，例如讀者訂閱新聞。而我是這麼理解觀察者模式的；當我在意的「新聞中心」有更新時，它會通知我，我再去看它的更新為何，在參考書中通常會將新聞中心這個角色稱為「主題」，讀者稱為「觀察者」，下面的範例就會以讀者訂閱新聞去做解釋。主要會分為三段： 主題 觀察者 註冊及發送通知 主題 (Subject)首先先來定義「新聞中心」會做什麼事，假設它有以下的三個功能： 接受讀者訂閱 增加新聞 通知讀者 我們將這三個功能定義成一個介面，然後簡單定義新聞類別，最後就是實作新聞中心： ISubject.cs123456789101112131415161718192021222324/*ISubject.cs*/namespace DemoCode.DesignPattern.Observer{ public interface ISubject { /// &lt;summary&gt; /// 訂閱者註冊 /// &lt;/summary&gt; /// &lt;param name=&quot;observer&quot;&gt;訂閱者&lt;/param&gt; void RegisterObserver(IObserver observer); /// &lt;summary&gt; /// 通知訂閱者 /// &lt;/summary&gt; void NotifyObservers(); /// &lt;summary&gt; /// 增加新聞 /// &lt;/summary&gt; /// &lt;param name=&quot;news&quot;&gt;&lt;/param&gt; void AddNews(News news); }} NewsCenter.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*NewsCenter*/using System.Collections.Generic;namespace DemoCode.DesignPattern.Observer{ public class NewsCenter : ISubject { /// &lt;summary&gt; /// 訂閱者清單 /// &lt;/summary&gt; private List&lt;IObserver&gt; _itsObservers; /// &lt;summary&gt; /// 新聞清單 /// &lt;/summary&gt; public List&lt;News&gt; _newsList; public NewsCenter() { this._itsObservers = new List&lt;IObserver&gt;(); ``this._newsList = new List&lt;News&gt;(); } /// &lt;summary&gt; /// 通知訂閱者 /// &lt;/summary&gt; public void NotifyObservers() { foreach(var observer in this._itsObservers) { observer.Update(); } } /// &lt;summary&gt; /// 訂閱者註冊 /// &lt;/summary&gt; /// &lt;param name=&quot;observer&quot;&gt;訂閱者&lt;/param&gt; public void RegisterObserver(IObserver observer) { this._itsObservers.Add(observer); } /// &lt;summary&gt; /// 增加新聞 /// &lt;/summary&gt; /// &lt;param name=&quot;news&quot;&gt;&lt;/param&gt; public void AddNews(News news) { this._newsList.Add(news); this.NotifyObservers(); } }} News.cs123456789101112131415161718192021222324252627282930/*News.cs*/namespace DemoCode.DesignPattern.Observer{ /// &lt;summary&gt; /// 新聞 /// &lt;/summary&gt; public class News { /// &lt;summary&gt; /// 分類 /// &lt;/summary&gt; public CategoryEnum Category { get; set; } /// &lt;summary&gt; /// 作者 /// &lt;/summary&gt; public string Author { get; set; } /// &lt;summary&gt; /// 標題 /// &lt;/summary&gt; public string Title { get; set; } /// &lt;summary&gt; /// 內容 /// &lt;/summary&gt; public string Content { get; set; } }} CategoryEnum.cs1234567891011121314151617181920/*CategoryEnum.cs*/namespace DemoCode.DesignPattern.Observer{ /// &lt;summary&gt; /// 新聞分類 /// &lt;/summary&gt; public enum CategoryEnum { /// &lt;summary&gt; /// 政治 /// &lt;/summary&gt; Politics, /// &lt;summary&gt; /// 體育 /// &lt;/summary&gt; Sports }} 觀察者 (Observer)現實生活中，通常是讀者收到新聞更新的通知後，再決定要做什麼，我們先簡單定義讀者只會做 Update() 這個動作 IObserver.cs123456789101112/*IObserver.cs*/namespace DemoCode.DesignPattern.Observer{ public interface IObserver { /// &lt;summary&gt; /// 更新訊息 /// &lt;/summary&gt; void Update(); }} Reader.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*Reader.cs*/using System;namespace DemoCode.DesignPattern.Observer{ public class Reader : IObserver { /// &lt;summary&gt; /// 訂閱者 /// &lt;/summary&gt; private string _readerName; /// &lt;summary&gt; /// 訂閱類型 /// &lt;/summary&gt; private CategoryEnum _registeredCategory; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;readerName&quot;&gt;訂閱者&lt;/param&gt; /// &lt;param name=&quot;category&quot;&gt;訂閱類型&lt;/param&gt; public Reader(string readerName, CategoryEnum category) { this._readerName = readerName; this._registeredCategory = category; this.RegisterMessage(readerName, category); } /// &lt;summary&gt; /// 更新訊息 /// &lt;/summary&gt; public void Update() { Console.WriteLine($&quot;{this._readerName} 訂閱的新聞中心有新的新聞，但不知道新聞類型&quot;); } /// &lt;summary&gt; /// 訂閱訊息 /// &lt;/summary&gt; /// &lt;param name=&quot;readerName&quot;&gt;訂閱者&lt;/param&gt; /// &lt;param name=&quot;category&quot;&gt;訂閱類型&lt;/param&gt; private void RegisterMessage(string readerName, CategoryEnum category) { Console.WriteLine($&quot;{readerName} 訂閱了新聞類型：{category}&quot;); } }} 註冊及發送通知最後我們來建立「新聞中心」及「讀者」，並新增幾則新聞看看結果： Program.cs1234567891011121314151617181920212223242526272829/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;using DemoCode.DesignPattern.Observer;namespace DemoCode{ class Program { static void Main(string[] args) { // Observer ISubject newsCenter = new NewsCenter(); IObserver reader1 = new Reader(&quot;Jack&quot;, CategoryEnum.Politics); IObserver reader2 = new Reader(&quot;Lily&quot;, CategoryEnum.Sports); newsCenter.RegisterObserver(reader1); newsCenter.RegisterObserver(reader2); News news1 = new News(){ Category = CategoryEnum.Sports, Author = &quot;Leo&quot;, Title = &quot;2021東京奧運&quot; }; News news2 = new News() { Category = CategoryEnum.Politics, Author = &quot;Jerry&quot;, Title = &quot;莫德納疫苗抵台&quot; }; newsCenter.AddNews(news1); newsCenter.AddNews(news2); } }} 拉模型與推模型拉模型 (pull-model)以上的範例我們可以得知，讀者只收到新聞中心通知說有新的新聞，但不知道新聞類型為何，收到通知後讀者需要去「拉」 newsList 才知道該新聞為何，所以此類型稱為拉模型 (pull-model)。 推模型 (push-model)如果只想在收到特定新聞類型時才做相對應的事情，可以在 NotifyObservers() 時多傳入一個參數，讓訂閱者根據傳入參數決定要做什麼事，這種傳入參數的方式即為推模型 (push-model)。Github 的範例即為以推模型做示範，並以 NotifyObservers(CategoryEnum category) 通知讀者新增的新聞類型為何。 完整程式碼請參考 結論觀察者模式解決了「主題」更新後通知多個「觀察者」，且因為使用介面解了「主題」及「觀察者」間的耦合，每個訂閱者可以在收到通知後決定後續的動作。簡單介紹了拉模型與推模型，決定該使用何者取決於使用情境。 參考OBSERVER 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐[Design Pattern] 觀察者模式 (Observer Pattern) 我也能夠辦報社","link":"/2021/07/12/Observer-Pattern/"},{"title":"[Design Pattern] Strategy 模式","text":"上一篇有提到，Template Method Pattern 違反了 DIP 原則，在寫程式時最需要注意的就是耦合性，倘若程式之間的耦合性高，修改一個類別結果造成所有繼承他的類別都需要修改，這樣的維護成本太高，而 Strategy Pattern 提供了解法。接續上一篇的範例，我們使用 Strategy 模式再重寫一次，會分為以下幾個步驟： 定義料理的抽象介面 實作中式料理類別 實作料理類別 定義料理的抽象介面首先先定義一個介面 ICooking，可以想像一下，如果做中式料理跟西式料理，有什麼步驟是相同的，但是詳細實作方法卻是不同的。以我們之前的範例，我將 準備材料 跟 烹飪 這兩個方法抽成介面，另外，在做菜前一定會知道要做什麼料理，所以我把 料理名稱 這個變數也放在介面中，後續繼承 ICooking 介面的類別，則需要實作這幾個方法及宣告屬性： 12345678910111213141516171819202122232425/*ICooking.cs*/namespace DemoCode.DesignPattern.Strategy{ /// &lt;summary&gt; /// 烹飪步驟 /// &lt;/summary&gt; public interface ICooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; string DishName { get; set; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; void Prepare(); /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; void Cook(); }} 實作中式料理類別現在來實作中式料理，由於 ChineseDish 繼承了 ICooking，需要實作其方法，而料理名稱是在建立 ChineseDish 時注入。往後若要實作西式料理類別，則只要繼承 ICooking 並實作即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*ChineseDish.cs*/using System;using System.Collections.Generic;namespace DemoCode.DesignPattern.Strategy{ public class ChineseDish : ICooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; public string DishName { get; set; } /// &lt;summary&gt; /// 食材 /// &lt;/summary&gt; private List&lt;string&gt; _ingredients; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public ChineseDish(string dishName) { this.DishName = dishName; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; public void Prepare() { Console.WriteLine($&quot;今天要來做{this.DishName}&quot;); switch (this.DishName) { case &quot;辣炒牛肉空心菜&quot;: this._ingredients = new List&lt;string&gt; { &quot;辣椒&quot;, &quot;空心菜&quot;, &quot;牛肉&quot; }; break; } //// 洗菜 this.Clean(); //// 切菜 this.Cut(); Console.WriteLine(&quot;材料準備好了&quot;); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public void Cook() { Console.WriteLine(&quot;中式料理當然要用鍋炒，材料有:{0}&quot;, string.Join(&quot;，&quot;, this._ingredients)); Console.WriteLine(&quot;菜煮好了&quot;); } /// &lt;summary&gt; /// 洗菜 /// &lt;/summary&gt; private void Clean() { Console.WriteLine(&quot;菜洗好了&quot;); } /// &lt;summary&gt; /// 切菜 /// &lt;/summary&gt; private void Cut() { Console.WriteLine(&quot;菜切好了&quot;); } }} 實作料理類別接下來我們來實作料理類別 Cooking，你可以想像成這個類別是餐廳的內場，它可以製作中式料理或是西式料理，只管跟他點菜即可。另外像 SetDish 及 Done 這兩個方法，因為做任何料理都有這兩個步驟，且實作細節皆相同，所以我把它放在 Cooking 類別中並實作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Cooking.cs*/using System;namespace DemoCode.DesignPattern.Strategy{ public class Cooking { /// &lt;summary&gt; /// ICooking /// &lt;/summary&gt; private ICooking _cooking; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;cooking&quot;&gt;&lt;/param&gt; public Cooking(ICooking cooking) { this._cooking = cooking; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; public void Prepare() { this._cooking.Prepare(); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public void Cook() { this._cooking.Cook(); } /// &lt;summary&gt; /// 裝盤 /// &lt;/summary&gt; public void SetDish() { Console.WriteLine($&quot;{this._cooking.DishName}好了，可以上菜囉&quot;); } /// &lt;summary&gt; /// 完成 /// &lt;/summary&gt; public void Done() { Console.WriteLine(&quot;完成上菜，來整理廚房&quot;); this.CleanUp(); } /// &lt;summary&gt; /// 整理廚房 /// &lt;/summary&gt; private void CleanUp() { Console.WriteLine(&quot;廚房整理好了&quot;); } }} 最後來看結果： 12345678910111213141516171819namespace DemoCode{ class Program { static void Main(string[] args) { // 先定義要做中式料理，並注入料理名稱 var dish = new DesignPattern.Strategy.ChineseDish(&quot;辣炒牛肉空心菜&quot;); // 將 dish 注入至 Cooking 類別 var cook = new DesignPattern.Strategy.Cooking(dish); cook.Prepare(); cook.Cook(); cook.SetDish(); cook.Done(); } }} 輸出結果如下，跟我們在 Template Method Pattern 得到的結果一樣： 123456789今天要來做辣炒牛肉空心菜菜洗好了菜切好了材料準備好了中式料理當然要用鍋炒，材料有:辣椒，空心菜，牛肉菜煮好了辣炒牛肉空心菜好了，可以上菜囉完成上菜，來整理廚房廚房整理好了 完整程式碼請參考 結論Strategy Pattern 的好處在於可擴充性及靈活度，往後若需要製作印度料理或是法式料理，則只要建立一個繼承 ICooking 介面的類別，在要新增 Cooking 類別時再注入。 這兩種 Pattern 可以想像成你想開一間什麼料理都有的餐廳，若是使用 Template Method Pattern，你需要每個料理都建立一個攤位，然後依據你想要的料理去各別的攤位點餐；而 Strategy Pattern 就好比你只需要跟中央廚房說你要什麼料理，無需東奔西跑。 參考TEMPLATE METHOD 模式和 STRATEGY 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/02/12/Strategy-Pattern/"},{"title":"[Design Pattern] Template Method 模式","text":"Template Method Pattern，顧名思義它就是一個模板，必須要在它指定的框架內完成實作。 所以要使用 Template Method Pattern，可以分為幾個步驟： 定義父類別抽象類型，也就是定義框架 子類別類型繼承父類別 子類別類型實作父類別的抽象方法 定義父類別抽象類型讓我們以「烹飪」當作範例，首先要定義烹飪會需要完成哪些步驟： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Cooking.cs*/using System;namespace TemplateMethodPattern{ /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public abstract class Cooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; public string _dishName; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public Cooking(string dishName) { this._dishName = dishName; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public abstract void Prepare(); /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract void Cook(); /// &lt;summary&gt; /// 裝盤 /// &lt;/summary&gt; public void SetDish() { Console.WriteLine($&quot;{this._dishName}好了，可以上菜囉&quot;); } /// &lt;summary&gt; /// 完成 /// &lt;/summary&gt; public void Done() { Console.WriteLine(&quot;完成上菜，來整理廚房&quot;); this.CleanUp(); } /// &lt;summary&gt; /// 整理廚房 /// &lt;/summary&gt; private void CleanUp() { Console.WriteLine(&quot;廚房整理好了&quot;); } }} 實作父類別的抽象方法今天要做一道辣炒牛肉空心菜，我們建立一個子類別中式料理 ChineseDish，繼承父類別，並實作父類別的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*ChineseDish.cs*/using System;using System.Collections.Generic;namespace TemplateMethodPattern{ /// &lt;summary&gt; /// 中式料理 /// &lt;/summary&gt; public class ChineseDish : Cooking { /// &lt;summary&gt; /// 食材 /// &lt;/summary&gt; private List&lt;string&gt; _ingredients; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public ChineseDish(string dishName) : base(dishName) { } //// 準備材料 public override void Prepare() { Console.WriteLine($&quot;今天要來做{this._dishName}&quot;); switch (this._dishName) { case &quot;辣炒牛肉空心菜&quot;: this._ingredients = new List&lt;string&gt; { &quot;辣椒&quot;, &quot;空心菜&quot;, &quot;牛肉&quot; }; break; } //// 洗菜 this.Clean(); //// 切菜 this.Cut(); Console.WriteLine(&quot;材料準備好了&quot;); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public override void Cook() { Console.WriteLine(&quot;中式料理當然要用鍋炒，材料有:{0}&quot;, string.Join(&quot;，&quot;, this._ingredients)); Console.WriteLine(&quot;菜煮好了&quot;); } /// &lt;summary&gt; /// 洗菜 /// &lt;/summary&gt; private void Clean() { Console.WriteLine(&quot;菜洗好了&quot;); } /// &lt;summary&gt; /// 切菜 /// &lt;/summary&gt; private void Cut() { Console.WriteLine(&quot;菜切好了&quot;); } }} 最後來看看結果： 1234567891011121314151617181920/*Program.cs*/using System;using System.Collections.Generic;namespace TemplateMethodPattern{ class Program { static void Main(string[] args) { var dish = new ChineseDish(&quot;辣炒牛肉空心菜&quot;); dish.Prepare(); dish.Cook(); dish.SetDish(); dish.Done(); } }} 輸出結果如下： 123456789今天要來做辣炒牛肉空心菜菜洗好了菜切好了材料準備好了中式料理當然要用鍋炒，材料有:辣椒，空心菜，牛肉菜煮好了辣炒牛肉空心菜好了，可以上菜囉完成上菜，來整理廚房廚房整理好了 完整程式碼請參考 結論這樣就完成了我們的中式料理，也可以用相同的方式做其他類型的料理。你可以想像成 Template Method Pattern 就像是你看著食譜做菜，只要照著“食譜”這個框架完成即可。不過 Template Method Pattern 是一種強烈的繼承關係，違反了 DIP 原則：高層模組不應該相依於低層模組，兩者都應該相依於抽象。下一篇介紹的 Strategy Design Pattern 解決了這個問題。 參考TEMPLATE METHOD 模式和 STRATEGY 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐Wiki - Template method pattern樣板方法模式","link":"/2021/02/11/Template-Method-Pattern/"},{"title":"如何解決因為 DateTime.Now 導致無法通過單元測試","text":"在寫程式時，我們很常用 DateTime.Now 來取得現在的時間。但這樣會遇到一個問題：若要為該方法寫測試時，會因為使用 DateTime.Now，每次取得的時間都不同，導致測試無法通過。 現在有個方法單純的回傳字串，但因為 timeNow 是不固定的，導致測試無法通過，這邊介紹兩種方法，都可以解決此問題。 1234567public string CreateMessage(){ DateTime timeNow = DateTime.Now; string result = &quot;Time now is &quot; + timeNow.ToString(); return result;} 1. 用抽象方法取得現在時間我們可以用一個抽象方法取得現在時間，寫測試時只要複寫該方法，就能讓取得時間為固定值。這樣做會需要用 StubTimeLogger 去繼承 TimeLogger，並覆寫抽象方法 GetTimeNow。 TimeLogger.cs:123456789101112131415161718192021222324252627282930using System;namespace Test.UnitTest.SystemTime{ public class TimeLogger { public TimeLogger() { } /// &lt;summary&gt; /// 取得現在時間字串 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string CreateMessage() { DateTime timeNow = this.GetTimeNow(); string result = $&quot;Time now is {timeNow:yyyy/MM/dd H:mm:ss}&quot;; return result; } /// &lt;summary&gt; /// 取得現在時間 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual DateTime GetTimeNow() { return DateTime.Now; } }} TimeLoggerTest.cs:12345678910111213141516171819202122232425262728293031323334353637383940414243using Microsoft.VisualStudio.TestTools.UnitTesting;using System;namespace Test.UnitTest.SystemTime{ [TestClass] public class TimeLoggerTest { public TimeLoggerTest() { } [TestMethod] public void 印出現在時間_使用StubTimeLogger() { //// Arrange DateTime dateTime = new DateTime(2021, 6, 6, 13, 13, 13); StubTimeLogger timeLogger = new StubTimeLogger(dateTime); //// Act var actual = timeLogger.CreateMessage(); var expected = &quot;Time now is 2021/06/06 13:13:13&quot;; //// Assert Assert.AreEqual(actual, expected); } /// &lt;summary&gt; /// StubTimeLogger /// &lt;/summary&gt; public class StubTimeLogger : TimeLogger { private DateTime _dateTime; public StubTimeLogger(DateTime dateTime) { this._dateTime = dateTime; } public override DateTime GetTimeNow() { return this._dateTime; } } }} 2. 建立 SystemTime 類別來取得時間使用 SystemTime 類別來取得時間，這種寫法就不用建立一個 StubTimeLogger 再複寫抽象方法。 TimeLoggerUsingSystemTime.cs:12345678910111213141516171819202122232425262728293031323334using Microsoft.VisualStudio.TestTools.UnitTesting;using System;namespace Test.UnitTest.SystemTime{ public class TimeLoggerUsingSystemTime { /// &lt;summary&gt; /// SystemTime /// &lt;/summary&gt; private SystemTime _systemTime; /// &lt;summary&gt; /// TimeLogger /// &lt;/summary&gt; /// &lt;param name=&quot;systemTime&quot;&gt;&lt;/param&gt; public TimeLoggerUsingSystemTime(SystemTime systemTime) { this._systemTime = systemTime; } /// &lt;summary&gt; /// 取得現在時間字串，使用 SystemTime /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string CreateMessage_SystemTime() { DateTime timeNow = this._systemTime.Now; string result = $&quot;Time now is {timeNow:yyyy/MM/dd H:mm:ss}&quot;; return result; } }} SystemTime.cs:1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;namespace Test.UnitTest.SystemTime{ public class SystemTime { private DateTime _date; public SystemTime() { } /// &lt;summary&gt; /// 設定時間 /// &lt;/summary&gt; /// &lt;param name=&quot;custom&quot;&gt;&lt;/param&gt; public void Set(DateTime custom) { this._date = custom; } /// &lt;summary&gt; /// 重置時間 /// &lt;/summary&gt; public void Reset() { this._date = DateTime.MinValue; } /// &lt;summary&gt; /// 取得現在時間 /// &lt;/summary&gt; public DateTime Now { get { if(this._date != DateTime.MinValue) { return this._date; } return DateTime.Now; } } }} TimeLoggerUsingSystemTimeTest.cs:12345678910111213141516171819202122232425262728using Microsoft.VisualStudio.TestTools.UnitTesting;using System;namespace Test.UnitTest.SystemTime{ [TestClass] public class TimeLoggerUsingSystemTimeTest { public TimeLoggerUsingSystemTimeTest() { } [TestMethod] public void 印出現在時間_使用SystemTime() { //// Arrange SystemTime systemTime = new SystemTime(); DateTime customDateTime = new DateTime(2021, 6, 6, 13, 13, 13); systemTime.Set(customDateTime); TimeLoggerUsingSystemTime timeLogger = new TimeLoggerUsingSystemTime(systemTime); //// Act var actual = timeLogger.CreateMessage_SystemTime(); var expected = &quot;Time now is 2021/06/06 13:13:13&quot;; //// Assert Assert.AreEqual(expected, actual); } }} 完整程式碼請參考 結論今天介紹了兩種方法，以解決因為使用 DateTime.Now 而無法通過單元測試的問題，我個人是比較喜歡方法一，方法二需注意是否有適時的 Reset，否則可能會取得非預期的時間。 參考Chapter 7 測試階層與組織．單元測試的藝術 第二版","link":"/2021/06/19/SystemTime-For-UnitTest/"},{"title":"[Design Pattern] Visitor 模式 (一)","text":"有時會需要對既有的類別新增方法，但該方法又會因為不同的類別有些微的差異，最土炮的方法是在各個類別中實作該方法，但如果下次又有類似的需求，又要再次修改各個類別，這樣無法遵守開放封閉原則。 這時可以使用訪問者模式，在不改變既有類別的情況下，將欲新增的方法收攏至訪問者類別中，【無瑕的程式碼】書中介紹的訪問者種類有以下四種，我會各自發一篇文做介紹： Visitor 模式 Acyclic Visitor 模式 Decorator 模式 Extenstion Object 模式 Visitor 模式現在有兩種交通工具；機車和巴士，假設乘客只在意三個項目：馬力、限乘人數、有沒有冷氣．將這三個屬性定義在介面，另外還需定義一個方法 Accept，使機車和巴士類別能夠讓 Visitor 訪問。 12345678910111213141516171819202122/*IVisitor.cs*/namespace DemoCode.DesignPattern.Visitor.OriginVisitor{ /// &lt;summary&gt; /// IVisitor /// &lt;/summary&gt; public interface IVisitor { /// &lt;summary&gt; /// Visit for Motor /// &lt;/summary&gt; /// &lt;param name=&quot;motor&quot;&gt;&lt;/param&gt; void Visit(Motor motor); /// &lt;summary&gt; /// Visit for Bus /// &lt;/summary&gt; /// &lt;param name=&quot;bus&quot;&gt;&lt;/param&gt; void Visit(Bus bus); }} 12345678910111213141516171819202122232425262728293031/*ITransportation.cs*/namespace DemoCode.DesignPattern.Visitor.OriginVisitor{ /// &lt;summary&gt; /// 交通工具 /// &lt;/summary&gt; public interface ITransportation { /// &lt;summary&gt; /// 馬力 /// &lt;/summary&gt; decimal Power { get; set; } /// &lt;summary&gt; /// 限乘人數 /// &lt;/summary&gt; int NumberOfPassenger { get; set; } /// &lt;summary&gt; /// 是否有冷氣 /// &lt;/summary&gt; bool HasAirConditioner { get; set; } /// &lt;summary&gt; /// Accept /// &lt;/summary&gt; /// &lt;param name=&quot;visitor&quot;&gt;&lt;/param&gt; void Accept(IVisitor visitor); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*Motor.cs*/namespace DemoCode.DesignPattern.Visitor.OriginVisitor{ /// &lt;summary&gt; /// 機車 /// &lt;/summary&gt; public class Motor : ITransportation { /// &lt;summary&gt; /// 馬力 /// &lt;/summary&gt; public decimal Power { get; set; } /// &lt;summary&gt; /// 限乘人數 /// &lt;/summary&gt; public int NumberOfPassenger { get; set; } /// &lt;summary&gt; /// 是否有冷氣 /// &lt;/summary&gt; public bool HasAirConditioner { get; set; } /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;power&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;numberOfPassenger&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hasAirConditioner&quot;&gt;&lt;/param&gt; public Motor(decimal power, int numberOfPassenger, bool hasAirConditioner) { this.Power = power; this.NumberOfPassenger = numberOfPassenger; this.HasAirConditioner = hasAirConditioner; } /// &lt;summary&gt; /// Accept /// &lt;/summary&gt; /// &lt;param name=&quot;visitor&quot;&gt;&lt;/param&gt; public void Accept(IVisitor visitor) { visitor.Visit(this); } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*Bus.cs*/namespace DemoCode.DesignPattern.Visitor.OriginVisitor{ /// &lt;summary&gt; /// 巴士 /// &lt;/summary&gt; public class Bus : ITransportation { /// &lt;summary&gt; /// 馬力 /// &lt;/summary&gt; public decimal Power { get; set; } /// &lt;summary&gt; /// 限乘人數 /// &lt;/summary&gt; public int NumberOfPassenger { get; set; } /// &lt;summary&gt; /// 是否有冷氣 /// &lt;/summary&gt; public bool HasAirConditioner { get; set; } /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;power&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;numberOfPassenger&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;hasAirConditioner&quot;&gt;&lt;/param&gt; public Bus(decimal power, int numberOfPassenger, bool hasAirConditioner) { this.Power = power; this.NumberOfPassenger = numberOfPassenger; this.HasAirConditioner = hasAirConditioner; } /// &lt;summary&gt; /// Accept /// &lt;/summary&gt; /// &lt;param name=&quot;visitor&quot;&gt;&lt;/param&gt; public void Accept(IVisitor visitor) { visitor.Visit(this); } }} 實作 Visitor 類別我們使用名為雙重分發 (dual dispatch) 的技術，這項技術是 Visitor 模式的核心機制，這個雙重分發涉及了兩個多型分發，第一個是機車及巴士類別的 Accept 方法，我們可以根據該分發辨別出是機車還是巴士類別呼叫了 Accept 方法；第二個是 Accept 方法所呼叫的 Visit 方法，根據上一個多型分發，判斷出是哪一個類別，再呼叫該類別所要執行的特定函式。接著我們根據不同的類別，實作不同的 Visit 方法： 123456789101112131415161718192021222324252627282930313233/*Visitor.cs*/using System;namespace DemoCode.DesignPattern.Visitor.OriginVisitor{ /// &lt;summary&gt; /// Visitor /// &lt;/summary&gt; public class Visitor : IVisitor { /// &lt;summary&gt; /// Visit for Motor /// &lt;/summary&gt; /// &lt;param name=&quot;motor&quot;&gt;&lt;/param&gt; public void Visit(Motor motor) { Console.WriteLine($&quot;這是台機車，我只在意馬力:{motor.Power}&quot;); } /// &lt;summary&gt; /// Visit for Bus /// &lt;/summary&gt; /// &lt;param name=&quot;bus&quot;&gt;&lt;/param&gt; public void Visit(Bus bus) { var ifHasAirConditioner = bus.HasAirConditioner == true ? &quot;有冷氣&quot; : &quot;沒有冷氣&quot;; Console.WriteLine($&quot;這是台公車，我只在意限乘人數:{bus.NumberOfPassenger},&quot; + $&quot;以及有沒有冷氣:{ifHasAirConditioner}&quot;); } }} 12345678910111213/*Program.cs*/class Program{ static void Main(string[] args) { var bus = new Bus(1000, 20, true); var motor = new Motor(100, 2, false); var visitor = new Visitor(); bus.Accept(visitor); motor.Accept(visitor); }} 最後輸出結果如下： 12我是台公車，我只在意限乘人數:20,以及有沒有冷氣:有冷氣我是台機車，我只在意馬力:100 完整程式碼請參考 結論Visitor 模式讓我們在不修改既有類別的情形下，替巴士及機車類別新增了方法。維基百科說道：訪問者模式是一種將算法與對象結構分離的軟體設計模式。若類別不常異動 (e.g. 新增一個飛機類別)，但常常需要新增方法，則可以使用 Visitor 模式。 參考VISITOR 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐Wiki - 訪問者模式每個人關心的點都不同 - 訪問者模式 (Visitor Pattern)訪問者模式 (Visitor Pattern)","link":"/2022/02/02/Visitor-Pattern/"},{"title":"[.NET Core] 用微軟的 DI 工具優雅地註冊多個服務","text":".NET Core 支援相依性注入 (Depedency Injection) 的設計模式，以往的 .NET Framework 在不支援 DI 的時候，我們會利用一些套件幫助我們完成這件事，例如 Autofac。假設現在我們有多個服務要註冊，使用 Autofac 來做 DI，可以使用以下的方法實現： 12345678910111213141516public class ServiceDI : Autofac.Module{ protected override void Load(ContainerBuilder builder) { /// 一個一個註冊 builder.RegisterType&lt;ServiceA&gt;().As&lt;IServiceA&gt;().WithAttributeFiltering(); builder.RegisterType&lt;ServiceB&gt;().As&lt;IServiceB&gt;().WithAttributeFiltering(); builder.RegisterType&lt;ServiceC&gt;().As&lt;IServiceC&gt;().WithAttributeFiltering(); /// 一次註冊多個 var serviceTypes = Assembly.Load(&quot;Where.My.Services.At&quot;); builder.RegisterAssemblyTypes(serviceTypes) .AsImplementedInterfaces() .WithAttributeFilter(); } } 現在我們想用微軟的 DI 工具來達到一樣的事情，若參考微軟官方的教學文件，也是教大家一個一個註冊，後來翻了一下文件，發現其實也有跟上面 Autofac 一樣，可以用參數型別為 Type 的方法來進行註冊：AddScoped(IServiceCollection, Type, Type)。 123456789101112131415161718192021using System.Linq;using System.Reflection;using Microsoft.Extensions.DependencyInjection;public static class ServiceMicrosoftDI{ public static void RegisterService(this IServiceCollection services) { var serviceTypes = Assembly.Load(&quot;Where.My.Services.At&quot;); var implementationTypes = serviceTypes.GetTypes().Where(i =&gt; i.Name.StartsWith(&quot;Service&quot;) &amp;&amp; i.IsClass); foreach(var implementationType in implementationTypes) { var serviceName = string.Format(&quot;I{0}&quot;, implementationType.Name); var serviceType = implementationType.GetInterface(serviceName); services.AddScoped(serviceType, implementationType); } }} 最後在 Startup.cs 中註冊 12345public void ConfigureServices(IServiceCollection services){ services.AddControllers(); services.RegisterService();} 上面的寫法有個前提是 Interface 和實作的 Class，命名有一個 Pattern 存在 (即開頭差一個 I )，如果有其他更好的寫法歡迎提供。 參考・How to register a service with multiple interfaces in ASP.NET Core DI・微軟官方文件 - .NET 中的相依性插入・微軟官方文件 - ServiceCollectionServiceExtensions.AddScoped 方法","link":"/2021/12/08/%EF%BC%ADicrosoft-DI/"},{"title":"[Python] 使用 pyenv 管理 python 版本","text":"pyenv 可以協助管理 python 的版本，讓你在 python2、python3 間隨意切換，此篇會紀錄我是如何安裝 pyenv 的，以下是我的系統配置： 作業系統：MacOS Mojave 10.14.6終端機：bash terminal 會分為以下步驟： homebrew 安裝 pyenv 輸入 pyen init 修改 .bash_profile 使 .bash_profile 生效 用 pyenv 安裝 python 版本 驗證 Step01. homebrew 安裝 pyenv不知道 homebrew 的可以估狗一下安裝完 homebrew 後於終端機執行以下指令 1brew install pyenv Step02. 輸入 pyen init應該會跑出一個 guideline，告訴你要怎麼設定環境變數，以我的例子，我先將以下指令複製起來 123export PYENV_ROOT=&quot;$HOME/.pyenv&quot;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;eval &quot;$(pyenv init --path)&quot; Step03. 修改 .bash_profile將上一步複製的指令，新增於 .bash_profile 檔案最後，.bash_profile 通常會放在 ~/ 路徑下，你可以執行以下指令確認該檔案是否存在 12cd ~cat .bash_profile Step04. 使 .bash_profile 生效1source .bash_profile Step05. 用 pyenv 安裝 python 版本可以先執行以下指令，看有哪些版本可供安裝 1pyenv install --list 選定好版本後，用 pyenv 安裝 python 1pyenv install 3.8.0 安裝完後查看目前的版本，應有 system 以及剛剛安裝的版本 3.8.0 12345pyenv versions# 輸入上面的指令後應該有像下面的結果* system 3.8.0 (set by /Users/{當前登入的帳號}/.python-version) 接著選擇剛剛安裝的版本。使用 global 指令的話，之後你開啟終端機，呼叫 python 時都會使用這個版本，如果你只想要此次使用該版本，則使用指定 local 1pyenv global 3.8.0 Step06. 驗證12python -V # 理應為 3.8.0which python # 路徑理應是 /Users/{當前登入的帳號}/.pyenv/shims/python 參考[用舒服的姿勢開發 Python Project] Day 03 - Pyenv 基本使用Python 版本管理的好工具 - pyenv在 Mac 上用 pyenv 輕鬆安裝 Python3 (可直接支援安裝多種版本)","link":"/2022/05/15/Pyenv-In-MacOS/"},{"title":"[LeetCode] Two Sum","text":"題目：Two Sum難度：Easy 12345678910111213141516171819202122232425public class Solution { public int[] TwoSum(int[] nums, int target) { var result = new int[2]; var dict = new Dictionary&lt;int, int&gt;(); for (int i = 0;i &lt; nums.Length; i++) { var remain = target - nums[i]; if (dict.ContainsKey(remain)) { result[1] = i; result[0] = dict[remain]; return result; } if (dict.ContainsKey(nums[i]) == false) { dict.Add(nums[i],i); } } return null; }}","link":"/2023/02/24/LeetCode-TwoSum/"},{"title":"[LeetCode] Longest Substring Without Repeating Characters","text":"題目：Longest Substring Without Repeating Characters難度：Medium 技巧在於使用 Sliding Window 去解，左右指標會一直移動，直到遍歷整個字串，即左右指標重疊。 12345678910111213141516171819202122232425262728293031323334353637public class Solution { public int LengthOfLongestSubstring(string s) { if (s.Length == 0) { return 0; } // dict 的 key 為字母， value 為右邊的指標位置 IDictionary&lt;char, int&gt; dict = new Dictionary&lt;char, int&gt;(); int left = 0; int right = 0; int maxLength = 0; while (left &lt; s.Length &amp;&amp; right &lt; s.Length) { char c = s[right]; // 如果該字母存在於字典中，則移動左邊的指標 // 因為要開一個新的 Window，所以左邊指標要移至【已存在的 c 的位置 +1】 if (dict.ContainsKey(c)) { left = Math.Max(dict[c] + 1, left); } // 如果該字母存在於字典中，則會更新成右邊指標的位置 // 如果該字母不存在於字典中，則會新增 dict[c] = right; // 比較【左右指標的位置差】與【前一次的最大長度】，何者比較大 maxLength = Math.Max(maxLength, right - left + 1); right += 1; } return maxLength; }} 參考演算法筆記系列 — Two Pointer 與 Sliding WindowYouTube: Longest Substring Without Repeating Characters","link":"/2023/02/25/LeetCode-Longest-Substring-Without-Repeating-Characters/"},{"title":"[Design Pattern] STATE 模式","text":"我們就以工程師的一天：Eat、Coding、Sleep 三種狀態，來示範 STATE 模式STATE 模式是由以下三個部分組成： Context：用來控制所有的狀態，其會是與客戶端的接口，客戶端只會與 Context 互動 State：定義各個狀態的抽象方法，ConcreteState 會繼承 State 並實作其方法 ConcreteState：Eat、Coding、Sleep，三種狀態的實作 定義 Context用列舉定義狀態因我們有三種 State，所以我用列舉定義出 State，待會 Context 裡的 GetState 方法會用到 123456789101112namespace DemoCode.DesignPattern.State{ /// &lt;summary&gt; /// 狀態定義 /// &lt;/summary&gt; public enum StateEnum { Eat, Sleep, Coding }} 定義 Context定義客戶端的接口 Context，其為所有狀態的控制中心，客戶端只能透過它執行各狀態的行為 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System;namespace DemoCode.DesignPattern.State{ /// &lt;summary&gt; /// 工程師 /// &lt;/summary&gt; public class SoftwareEngineer { private State _itsState; private Eat _eatState; private Sleep _sleepState; private Coding _codeingState; /// &lt;summary&gt; /// 工程師 /// &lt;/summary&gt; public SoftwareEngineer() { this._eatState = new Eat(); this._sleepState = new Sleep(); this._codeingState = new Coding(); // 預設狀態從吃飯開始 this._itsState = this._eatState; } /// &lt;summary&gt; /// 取得當前狀態 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetCurrentStateName() { Console.WriteLine($&quot;現在狀態：{this._itsState.StateName()}&quot;); return this._itsState.StateName(); } /// &lt;summary&gt; /// 取得狀態 /// &lt;/summary&gt; /// &lt;param name=&quot;state&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public State GetState(StateEnum state) { switch (state) { case StateEnum.Eat: return this._eatState; case StateEnum.Sleep: return this._sleepState; case StateEnum.Coding: return this._codeingState; default: throw new ArgumentException(); } } /// &lt;summary&gt; /// 設定狀態 /// &lt;/summary&gt; /// &lt;param name=&quot;state&quot;&gt;&lt;/param&gt; public void SetState(State state) { this._itsState = state; } /// &lt;summary&gt; /// 行為 /// &lt;/summary&gt; public void Action() { this._itsState.Action(this); } }} 定義 State定義基底類別，各狀態類別會繼承此類別，並實作其方法 12345678910111213141516171819namespace DemoCode.DesignPattern.State{ public abstract class State { /// &lt;summary&gt; /// 狀態名稱 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract string StateName(); /// &lt;summary&gt; /// 行為 /// &lt;/summary&gt; public virtual void Action(SoftwareEngineer softwareEngineer) { } }} 實作 ConcreteState這邊放上 Eat.cs 的程式碼，其他兩種狀態差不多每個狀態類別實作基底類別宣告的方法，並自行決定完成動作後，下個狀態為何 1234567891011121314151617181920212223242526272829303132using System;namespace DemoCode.DesignPattern.State{ /// &lt;summary&gt; /// 吃飯 /// &lt;/summary&gt; public class Eat : State { /// &lt;summary&gt; /// 當前狀態名稱 /// &lt;/summary&gt; /// &lt;returns&gt;當前狀態名稱&lt;/returns&gt; public override string StateName() { return &quot;Eat&quot;; } /// &lt;summary&gt; /// 開始動作 /// &lt;/summary&gt; /// &lt;param name=&quot;softwareEngineer&quot;&gt;&lt;/param&gt; public override void Action(SoftwareEngineer softwareEngineer) { Console.WriteLine(&quot;該吃飯了&quot;); // 更改狀態 Console.WriteLine(&quot;吃完飯該寫程式了&quot;); var nextState = softwareEngineer.GetState(StateEnum.Coding); softwareEngineer.SetState(nextState); } }} 結果12345678910111213141516171819202122232425namespace DemoCode{ class Program { static void Main(string[] args) { var engineer = new SoftwareEngineer(); Console.WriteLine(&quot;Step01:&quot;); engineer.GetCurrentStateName(); engineer.Action(); Console.WriteLine(&quot;Step02:&quot;); engineer.GetCurrentStateName(); engineer.Action(); Console.WriteLine(&quot;Step03:&quot;); engineer.GetCurrentStateName(); engineer.Action(); Console.WriteLine(&quot;Step04:&quot;); engineer.GetCurrentStateName(); engineer.Action(); } }} 12345678910111213141516Step01:現在狀態：Eat該吃飯了吃完飯該寫程式了Step02:現在狀態：Coding該寫程式了寫完程式該睡覺了Step03:現在狀態：Sleep該睡覺了睡完覺該吃飯了Step04:現在狀態：Eat該吃飯了吃完飯該寫程式了 完整程式碼請參考 結論STATE 模式的好處是將各 State 的邏輯分離，在管理複雜的系統行為時很有幫助而 STATE 模式與 STRATEGY 模式看起來很相近，但差別在於，前者知道各 State 的存在，且能透過 Context 進行修改，後者則相反。如下圖可看出，Context 並不知道是哪個 Contrete Strategy 實作 method 的，而 State 會知道 Strategy 模式 參考STATE 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐wiki - state pattern狀態模式-State Pattern狀態模式 | State Pattern[Design Pattern] State 狀態模式","link":"/2023/02/28/State-Pattern/"},{"title":"[LeetCode] Longest Palindromic Substring","text":"題目：Longest Palindromic Substring難度：Medium 暴力解暴力解效能超差 1234567891011121314151617181920212223242526272829303132333435363738public class Solution { public string LongestPalindrome(string s) { string result = string.Empty; for (int i = 0; i &lt; s.Length; i++) { string currentString = string.Empty; for (int j = i; j &lt; s.Length; j++) { currentString = currentString += s[j].ToString(); bool isPalindrome = this.CheckIsPalindrome(currentString); if (isPalindrome == false) { continue; } result = currentString.Length &gt; result.Length ? currentString : result; } } return result; } private bool CheckIsPalindrome(string s) { for (int i = 0, j = s.Length - 1; j &gt; i; i++, j--) { if (s[i] != s[j]) { return false; } } return true; }}","link":"/2023/02/28/LeetCode-Longest-Palindrome-Substring/"}],"tags":[{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Revert","slug":"Revert","link":"/tags/Revert/"},{"name":"UnitTest","slug":"UnitTest","link":"/tags/UnitTest/"},{"name":".NET Core","slug":"NET-Core","link":"/tags/NET-Core/"},{"name":"Dependency Injection","slug":"Dependency-Injection","link":"/tags/Dependency-Injection/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"pyenv","slug":"pyenv","link":"/tags/pyenv/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Easy","slug":"Easy","link":"/tags/Easy/"},{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"}],"categories":[{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"UnitTest","slug":"UnitTest","link":"/categories/UnitTest/"},{"name":"Dependency Injection","slug":"Dependency-Injection","link":"/categories/Dependency-Injection/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}