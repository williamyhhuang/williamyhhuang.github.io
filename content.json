{"pages":[{"title":"About me","text":"大部分的程式碼是以 C# 示範，若有問題請與我聯繫williamyhhuang@gmail.com","link":"/about/index.html"}],"posts":[{"title":"[Design Pattern] Factory 模式","text":"假設我們今天要開一間玩具工廠，工廠生產的玩具有：金剛、哥吉拉，寫法可能像這樣： Program.cs12345678910111213141516171819/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;namespace DemoCode{ class Program { static void Main(string[] args) { IToy toy1 = new Gozilla(); IToy toy2 = new KingKong(); Console.WriteLine($&quot;Toy I made: {toy1.ToyName}&quot;); Console.WriteLine($&quot;Toy I made: {toy2.ToyName}&quot;); } }} IToy.cs123456789/*IToy.cs*/namespace DemoCode.DesignPattern.Factory{ public interface IToy { public string ToyName { get; set; } }} Gozilla.cs1234567891011121314/*Gozilla.cs*/namespace DemoCode.DesignPattern.Factory{ public class Gozilla : IToy { public string ToyName { get; set; } public Gozilla() { ToyName = &quot;Gozilla&quot;; } }} KingKong.cs1234567891011121314/*KingKong.cs*/namespace DemoCode.DesignPattern.Factory{ public class KingKong : IToy { public string ToyName { get; set; } public KingKong() { ToyName = &quot;KingKong&quot;; } }} 架構圖會像是這樣子，我們會在 Program 裡直接建立 KingKong、Gozilla 執行個體，如果這個類別不常變更，其實直接建立是沒有問題的，但如果是在開發階段，我們應當依賴於抽象介面，避免受類別變化帶來的影響。\b\b Factory 模式示範DIP 原則告訴我們：應該優先依賴於抽象類別，避免依賴於實體類別。所以我們新增一個工廠介面 IFactory，以及實作該介面的類別 Factory，藉由這個工廠來幫我們生產玩具： Program.cs123456789101112131415161718192021/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;namespace DemoCode{ class Program { static void Main(string[] args) { IFactory factory = new Factory(); IToy toy1 = factory.Make(&quot;KingKong&quot;); IToy toy2 = factory.Make(&quot;Gozilla&quot;); Console.WriteLine($&quot;Toy I made is: {toy1.ToyName}&quot;); Console.WriteLine($&quot;Toy I made is: {toy2.ToyName}&quot;); } }} IFactory.cs123456789/*IFactory.cs*/namespace DemoCode.DesignPattern.Factory{ public interface IFactory { IToy Make(string toyName); }} Factory.cs123456789101112131415161718192021222324252627/*Factory.cs*/using System;namespace DemoCode.DesignPattern.Factory{ public class Factory : IFactory { public Factory() { } public IToy Make(string toyName) { switch (toyName) { case &quot;Gozilla&quot;: return new Gozilla(); case &quot;KingKong&quot;: return new KingKong(); default: throw new ApplicationException($&quot;沒有生產該玩具: {toyName}&quot;); } } }} 我們在 Program 中建立一個 Factory 的類別實作，並將製作玩具的工作交給 Factory，這樣的話職責就很明確，工廠專職製造玩具，Program 只需直接使用 Factory 所回傳的類別實作。 完整程式碼請參考 結論Factory 模式使得高層模組不依賴於類別的實作，並遵守 DIP 原則，在程式的職責管理上也較為清楚明白。但如果你的類別是不常變更且穩定的，那也不需使用 Factory 模式，直接建立類別實作會省事許多。 參考Factory 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/04/04/Factory-Pattern/"},{"title":"[Design Pattern] Strategy 模式","text":"上一篇有提到，Template Method Pattern 違反了 DIP 原則，在寫程式時最需要注意的就是耦合性，倘若程式之間的耦合性高，修改一個類別結果造成所有繼承他的類別都需要修改，這樣的維護成本太高，而 Strategy Pattern 提供了解法。接續上一篇的範例，我們使用 Strategy 模式再重寫一次，會分為以下幾個步驟： 定義料理的抽象介面 實作中式料理類別 實作料理類別 定義料理的抽象介面首先先定義一個介面 ICooking，可以想像一下，如果做中式料理跟西式料理，有什麼步驟是相同的，但是詳細實作方法卻是不同的。以我們之前的範例，我將 準備材料 跟 烹飪 這兩個方法抽成介面，另外，在做菜前一定會知道要做什麼料理，所以我把 料理名稱 這個變數也放在介面中，後續繼承 ICooking 介面的類別，則需要實作這幾個方法及宣告屬性： 12345678910111213141516171819202122232425/*ICooking.cs*/namespace DemoCode.DesignPattern.Strategy{ /// &lt;summary&gt; /// 烹飪步驟 /// &lt;/summary&gt; public interface ICooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; string DishName { get; set; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; void Prepare(); /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; void Cook(); }} 實作中式料理類別現在來實作中式料理，由於 ChineseDish 繼承了 ICooking，需要實作其方法，而料理名稱是在建立 ChineseDish 時注入。往後若要實作西式料理類別，則只要繼承 ICooking 並實作即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*ChineseDish.cs*/using System;using System.Collections.Generic;namespace DemoCode.DesignPattern.Strategy{ public class ChineseDish : ICooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; public string DishName { get; set; } /// &lt;summary&gt; /// 食材 /// &lt;/summary&gt; private List&lt;string&gt; _ingredients; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public ChineseDish(string dishName) { this.DishName = dishName; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; public void Prepare() { Console.WriteLine($&quot;今天要來做{this.DishName}&quot;); switch (this.DishName) { case &quot;辣炒牛肉空心菜&quot;: this._ingredients = new List&lt;string&gt; { &quot;辣椒&quot;, &quot;空心菜&quot;, &quot;牛肉&quot; }; break; } //// 洗菜 this.Clean(); //// 切菜 this.Cut(); Console.WriteLine(&quot;材料準備好了&quot;); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public void Cook() { Console.WriteLine(&quot;中式料理當然要用鍋炒，材料有:{0}&quot;, string.Join(&quot;，&quot;, this._ingredients)); Console.WriteLine(&quot;菜煮好了&quot;); } /// &lt;summary&gt; /// 洗菜 /// &lt;/summary&gt; private void Clean() { Console.WriteLine(&quot;菜洗好了&quot;); } /// &lt;summary&gt; /// 切菜 /// &lt;/summary&gt; private void Cut() { Console.WriteLine(&quot;菜切好了&quot;); } }} 實作料理類別接下來我們來實作料理類別 Cooking，你可以想像成這個類別是餐廳的內場，它可以製作中式料理或是西式料理，只管跟他點菜即可。另外像 SetDish 及 Done 這兩個方法，因為做任何料理都有這兩個步驟，且實作細節皆相同，所以我把它放在 Cooking 類別中並實作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Cooking.cs*/using System;namespace DemoCode.DesignPattern.Strategy{ public class Cooking { /// &lt;summary&gt; /// ICooking /// &lt;/summary&gt; private ICooking _cooking; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;cooking&quot;&gt;&lt;/param&gt; public Cooking(ICooking cooking) { this._cooking = cooking; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; public void Prepare() { this._cooking.Prepare(); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public void Cook() { this._cooking.Cook(); } /// &lt;summary&gt; /// 裝盤 /// &lt;/summary&gt; public void SetDish() { Console.WriteLine($&quot;{this._cooking.DishName}好了，可以上菜囉&quot;); } /// &lt;summary&gt; /// 完成 /// &lt;/summary&gt; public void Done() { Console.WriteLine(&quot;完成上菜，來整理廚房&quot;); this.CleanUp(); } /// &lt;summary&gt; /// 整理廚房 /// &lt;/summary&gt; private void CleanUp() { Console.WriteLine(&quot;廚房整理好了&quot;); } }} 最後來看結果： 12345678910111213141516171819namespace DemoCode{ class Program { static void Main(string[] args) { // 先定義要做中式料理，並注入料理名稱 var dish = new DesignPattern.Strategy.ChineseDish(&quot;辣炒牛肉空心菜&quot;); // 將 dish 注入至 Cooking 類別 var cook = new DesignPattern.Strategy.Cooking(dish); cook.Prepare(); cook.Cook(); cook.SetDish(); cook.Done(); } }} 輸出結果如下，跟我們在 Template Method Pattern 得到的結果一樣： 123456789今天要來做辣炒牛肉空心菜菜洗好了菜切好了材料準備好了中式料理當然要用鍋炒，材料有:辣椒，空心菜，牛肉菜煮好了辣炒牛肉空心菜好了，可以上菜囉完成上菜，來整理廚房廚房整理好了 完整程式碼請參考 結論Strategy Pattern 的好處在於可擴充性及靈活度，往後若需要製作印度料理或是法式料理，則只要建立一個繼承 ICooking 介面的類別，在要新增 Cooking 類別時再注入。 這兩種 Pattern 可以想像成你想開一間什麼料理都有的餐廳，若是使用 Template Method Pattern，你需要每個料理都建立一個攤位，然後依據你想要的料理去各別的攤位點餐；而 Strategy Pattern 就好比你只需要跟中央廚房說你要什麼料理，無需東奔西跑。 參考TEMPLATE METHOD 模式和 STRATEGY 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/02/12/Strategy-Pattern/"},{"title":"如何解決因為 DateTime.Now 導致無法通過單元測試","text":"在寫程式時，我們很常用 DateTime.Now 來取得現在的時間。但這樣會遇到一個問題：若要為該方法寫測試時，會因為使用 DateTime.Now，每次取得的時間都不同，導致測試無法通過。 現在有個方法單純的回傳字串，但因為 timeNow 是不固定的，導致測試無法通過，這邊介紹兩種方法，都可以解決此問題。 1234567public string CreateMessage(){ DateTime timeNow = DateTime.Now; string result = &quot;Time now is &quot; + timeNow.ToString(); return result;} 1. 用抽象方法取得現在時間我們可以用一個抽象方法取得現在時間，寫測試時只要複寫該方法，就能讓取得時間為固定值。這樣做會需要用 StubTimeLogger 去繼承 TimeLogger，並覆寫抽象方法 GetTimeNow。 TimeLogger.cs:123456789101112131415161718192021222324252627282930using System;namespace Test.UnitTest.SystemTime{ public class TimeLogger { public TimeLogger() { } /// &lt;summary&gt; /// 取得現在時間字串 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string CreateMessage() { DateTime timeNow = this.GetTimeNow(); string result = $&quot;Time now is {timeNow:yyyy/MM/dd H:mm:ss}&quot;; return result; } /// &lt;summary&gt; /// 取得現在時間 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public virtual DateTime GetTimeNow() { return DateTime.Now; } }} TimeLoggerTest.cs:12345678910111213141516171819202122232425262728293031323334353637383940414243using Microsoft.VisualStudio.TestTools.UnitTesting;using System;namespace Test.UnitTest.SystemTime{ [TestClass] public class TimeLoggerTest { public TimeLoggerTest() { } [TestMethod] public void 印出現在時間_使用StubTimeLogger() { //// Arrange DateTime dateTime = new DateTime(2021, 6, 6, 13, 13, 13); StubTimeLogger timeLogger = new StubTimeLogger(dateTime); //// Act var actual = timeLogger.CreateMessage(); var expected = &quot;Time now is 2021/06/06 13:13:13&quot;; //// Assert Assert.AreEqual(actual, expected); } /// &lt;summary&gt; /// StubTimeLogger /// &lt;/summary&gt; public class StubTimeLogger : TimeLogger { private DateTime _dateTime; public StubTimeLogger(DateTime dateTime) { this._dateTime = dateTime; } public override DateTime GetTimeNow() { return this._dateTime; } } }} 2. 建立 SystemTime 類別來取得時間使用 SystemTime 類別來取得時間，這種寫法就不用建立一個 StubTimeLogger 再複寫抽象方法。 TimeLoggerUsingSystemTime.cs:12345678910111213141516171819202122232425262728293031323334using Microsoft.VisualStudio.TestTools.UnitTesting;using System;namespace Test.UnitTest.SystemTime{ public class TimeLoggerUsingSystemTime { /// &lt;summary&gt; /// SystemTime /// &lt;/summary&gt; private SystemTime _systemTime; /// &lt;summary&gt; /// TimeLogger /// &lt;/summary&gt; /// &lt;param name=&quot;systemTime&quot;&gt;&lt;/param&gt; public TimeLoggerUsingSystemTime(SystemTime systemTime) { this._systemTime = systemTime; } /// &lt;summary&gt; /// 取得現在時間字串，使用 SystemTime /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string CreateMessage_SystemTime() { DateTime timeNow = this._systemTime.Now; string result = $&quot;Time now is {timeNow:yyyy/MM/dd H:mm:ss}&quot;; return result; } }} SystemTime.cs:1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;namespace Test.UnitTest.SystemTime{ public class SystemTime { private DateTime _date; public SystemTime() { } /// &lt;summary&gt; /// 設定時間 /// &lt;/summary&gt; /// &lt;param name=&quot;custom&quot;&gt;&lt;/param&gt; public void Set(DateTime custom) { this._date = custom; } /// &lt;summary&gt; /// 重置時間 /// &lt;/summary&gt; public void Reset() { this._date = DateTime.MinValue; } /// &lt;summary&gt; /// 取得現在時間 /// &lt;/summary&gt; public DateTime Now { get { if(this._date != DateTime.MinValue) { return this._date; } return DateTime.Now; } } }} TimeLoggerUsingSystemTimeTest.cs:12345678910111213141516171819202122232425262728using Microsoft.VisualStudio.TestTools.UnitTesting;using System;namespace Test.UnitTest.SystemTime{ [TestClass] public class TimeLoggerUsingSystemTimeTest { public TimeLoggerUsingSystemTimeTest() { } [TestMethod] public void 印出現在時間_使用SystemTime() { //// Arrange SystemTime systemTime = new SystemTime(); DateTime customDateTime = new DateTime(2021, 6, 6, 13, 13, 13); systemTime.Set(customDateTime); TimeLoggerUsingSystemTime timeLogger = new TimeLoggerUsingSystemTime(systemTime); //// Act var actual = timeLogger.CreateMessage_SystemTime(); var expected = &quot;Time now is 2021/06/06 13:13:13&quot;; //// Assert Assert.AreEqual(expected, actual); } }} 完整程式碼請參考 結論今天介紹了兩種方法，以解決因為使用 DateTime.Now 而無法通過單元測試的問題，我個人是比較喜歡方法一，方法二需注意是否有適時的 Reset，否則可能會取得非預期的時間。 參考Chapter 7 測試階層與組織．單元測試的藝術 第二版","link":"/2021/06/19/SystemTime-For-UnitTest/"},{"title":"[Design Pattern] Template Method 模式","text":"Template Method Pattern，顧名思義它就是一個模板，必須要在它指定的框架內完成實作。 所以要使用 Template Method Pattern，可以分為幾個步驟： 定義父類別抽象類型，也就是定義框架 子類別類型繼承父類別 子類別類型實作父類別的抽象方法 定義父類別抽象類型讓我們以「烹飪」當作範例，首先要定義烹飪會需要完成哪些步驟： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Cooking.cs*/using System;namespace TemplateMethodPattern{ /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public abstract class Cooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; public string _dishName; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public Cooking(string dishName) { this._dishName = dishName; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public abstract void Prepare(); /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract void Cook(); /// &lt;summary&gt; /// 裝盤 /// &lt;/summary&gt; public void SetDish() { Console.WriteLine($&quot;{this._dishName}好了，可以上菜囉&quot;); } /// &lt;summary&gt; /// 完成 /// &lt;/summary&gt; public void Done() { Console.WriteLine(&quot;完成上菜，來整理廚房&quot;); this.CleanUp(); } /// &lt;summary&gt; /// 整理廚房 /// &lt;/summary&gt; private void CleanUp() { Console.WriteLine(&quot;廚房整理好了&quot;); } }} 實作父類別的抽象方法今天要做一道辣炒牛肉空心菜，我們建立一個子類別中式料理 ChineseDish，繼承父類別，並實作父類別的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*ChineseDish.cs*/using System;using System.Collections.Generic;namespace TemplateMethodPattern{ /// &lt;summary&gt; /// 中式料理 /// &lt;/summary&gt; public class ChineseDish : Cooking { /// &lt;summary&gt; /// 食材 /// &lt;/summary&gt; private List&lt;string&gt; _ingredients; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public ChineseDish(string dishName) : base(dishName) { } //// 準備材料 public override void Prepare() { Console.WriteLine($&quot;今天要來做{this._dishName}&quot;); switch (this._dishName) { case &quot;辣炒牛肉空心菜&quot;: this._ingredients = new List&lt;string&gt; { &quot;辣椒&quot;, &quot;空心菜&quot;, &quot;牛肉&quot; }; break; } //// 洗菜 this.Clean(); //// 切菜 this.Cut(); Console.WriteLine(&quot;材料準備好了&quot;); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public override void Cook() { Console.WriteLine(&quot;中式料理當然要用鍋炒，材料有:{0}&quot;, string.Join(&quot;，&quot;, this._ingredients)); Console.WriteLine(&quot;菜煮好了&quot;); } /// &lt;summary&gt; /// 洗菜 /// &lt;/summary&gt; private void Clean() { Console.WriteLine(&quot;菜洗好了&quot;); } /// &lt;summary&gt; /// 切菜 /// &lt;/summary&gt; private void Cut() { Console.WriteLine(&quot;菜切好了&quot;); } }} 最後來看看結果： 1234567891011121314151617181920/*Program.cs*/using System;using System.Collections.Generic;namespace TemplateMethodPattern{ class Program { static void Main(string[] args) { var dish = new ChineseDish(&quot;辣炒牛肉空心菜&quot;); dish.Prepare(); dish.Cook(); dish.SetDish(); dish.Done(); } }} 輸出結果如下： 123456789今天要來做辣炒牛肉空心菜菜洗好了菜切好了材料準備好了中式料理當然要用鍋炒，材料有:辣椒，空心菜，牛肉菜煮好了辣炒牛肉空心菜好了，可以上菜囉完成上菜，來整理廚房廚房整理好了 完整程式碼請參考 結論這樣就完成了我們的中式料理，也可以用相同的方式做其他類型的料理。你可以想像成 Template Method Pattern 就像是你看著食譜做菜，只要照著“食譜”這個框架完成即可。不過 Template Method Pattern 是一種強烈的繼承關係，違反了 DIP 原則：高層模組不應該相依於低層模組，兩者都應該相依於抽象。下一篇介紹的 Strategy Design Pattern 解決了這個問題。 參考TEMPLATE METHOD 模式和 STRATEGY 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐Wiki - Template method pattern樣板方法模式","link":"/2021/02/11/Template-Method-Pattern/"},{"title":"[Design Pattern] Observer 模式","text":"訂閱者模式在生活中處處可見，例如讀者訂閱新聞。而我是這麼理解觀察者模式的；當我在意的「新聞中心」有更新時，它會通知我，我再去看它的更新為何，在參考書中通常會將新聞中心這個角色稱為「主題」，讀者稱為「觀察者」，下面的範例就會以讀者訂閱新聞去做解釋。主要會分為三段： 主題 觀察者 註冊及發送通知 主題 (Subject)首先先來定義「新聞中心」會做什麼事，假設它有以下的三個功能： 接受讀者訂閱 增加新聞 通知讀者 我們將這三個功能定義成一個介面，然後簡單定義新聞類別，最後就是實作新聞中心： ISubject.cs123456789101112131415161718192021222324/*ISubject.cs*/namespace DemoCode.DesignPattern.Observer{ public interface ISubject { /// &lt;summary&gt; /// 訂閱者註冊 /// &lt;/summary&gt; /// &lt;param name=&quot;observer&quot;&gt;訂閱者&lt;/param&gt; void RegisterObserver(IObserver observer); /// &lt;summary&gt; /// 通知訂閱者 /// &lt;/summary&gt; void NotifyObservers(); /// &lt;summary&gt; /// 增加新聞 /// &lt;/summary&gt; /// &lt;param name=&quot;news&quot;&gt;&lt;/param&gt; void AddNews(News news); }} NewsCenter.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*NewsCenter*/using System.Collections.Generic;namespace DemoCode.DesignPattern.Observer{ public class NewsCenter : ISubject { /// &lt;summary&gt; /// 訂閱者清單 /// &lt;/summary&gt; private List&lt;IObserver&gt; _itsObservers; /// &lt;summary&gt; /// 新聞清單 /// &lt;/summary&gt; public List&lt;News&gt; _newsList; public NewsCenter() { this._itsObservers = new List&lt;IObserver&gt;(); ``this._newsList = new List&lt;News&gt;(); } /// &lt;summary&gt; /// 通知訂閱者 /// &lt;/summary&gt; public void NotifyObservers() { foreach(var observer in this._itsObservers) { observer.Update(); } } /// &lt;summary&gt; /// 訂閱者註冊 /// &lt;/summary&gt; /// &lt;param name=&quot;observer&quot;&gt;訂閱者&lt;/param&gt; public void RegisterObserver(IObserver observer) { this._itsObservers.Add(observer); } /// &lt;summary&gt; /// 增加新聞 /// &lt;/summary&gt; /// &lt;param name=&quot;news&quot;&gt;&lt;/param&gt; public void AddNews(News news) { this._newsList.Add(news); this.NotifyObservers(); } }} News.cs123456789101112131415161718192021222324252627282930/*News.cs*/namespace DemoCode.DesignPattern.Observer{ /// &lt;summary&gt; /// 新聞 /// &lt;/summary&gt; public class News { /// &lt;summary&gt; /// 分類 /// &lt;/summary&gt; public CategoryEnum Category { get; set; } /// &lt;summary&gt; /// 作者 /// &lt;/summary&gt; public string Author { get; set; } /// &lt;summary&gt; /// 標題 /// &lt;/summary&gt; public string Title { get; set; } /// &lt;summary&gt; /// 內容 /// &lt;/summary&gt; public string Content { get; set; } }} CategoryEnum.cs1234567891011121314151617181920/*CategoryEnum.cs*/namespace DemoCode.DesignPattern.Observer{ /// &lt;summary&gt; /// 新聞分類 /// &lt;/summary&gt; public enum CategoryEnum { /// &lt;summary&gt; /// 政治 /// &lt;/summary&gt; Politics, /// &lt;summary&gt; /// 體育 /// &lt;/summary&gt; Sports }} 觀察者 (Observer)現實生活中，通常是讀者收到新聞更新的通知後，再決定要做什麼，我們先簡單定義讀者只會做 Update() 這個動作 IObserver.cs123456789101112/*IObserver.cs*/namespace DemoCode.DesignPattern.Observer{ public interface IObserver { /// &lt;summary&gt; /// 更新訊息 /// &lt;/summary&gt; void Update(); }} Reader.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*Reader.cs*/using System;namespace DemoCode.DesignPattern.Observer{ public class Reader : IObserver { /// &lt;summary&gt; /// 訂閱者 /// &lt;/summary&gt; private string _readerName; /// &lt;summary&gt; /// 訂閱類型 /// &lt;/summary&gt; private CategoryEnum _registeredCategory; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;readerName&quot;&gt;訂閱者&lt;/param&gt; /// &lt;param name=&quot;category&quot;&gt;訂閱類型&lt;/param&gt; public Reader(string readerName, CategoryEnum category) { this._readerName = readerName; this._registeredCategory = category; this.RegisterMessage(readerName, category); } /// &lt;summary&gt; /// 更新訊息 /// &lt;/summary&gt; public void Update() { Console.WriteLine($&quot;{this._readerName} 訂閱的新聞中心有新的新聞，但不知道新聞類型&quot;); } /// &lt;summary&gt; /// 訂閱訊息 /// &lt;/summary&gt; /// &lt;param name=&quot;readerName&quot;&gt;訂閱者&lt;/param&gt; /// &lt;param name=&quot;category&quot;&gt;訂閱類型&lt;/param&gt; private void RegisterMessage(string readerName, CategoryEnum category) { Console.WriteLine($&quot;{readerName} 訂閱了新聞類型：{category}&quot;); } }} 註冊及發送通知最後我們來建立「新聞中心」及「讀者」，並新增幾則新聞看看結果： Program.cs1234567891011121314151617181920212223242526272829/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;using DemoCode.DesignPattern.Observer;namespace DemoCode{ class Program { static void Main(string[] args) { // Observer ISubject newsCenter = new NewsCenter(); IObserver reader1 = new Reader(&quot;Jack&quot;, CategoryEnum.Politics); IObserver reader2 = new Reader(&quot;Lily&quot;, CategoryEnum.Sports); newsCenter.RegisterObserver(reader1); newsCenter.RegisterObserver(reader2); News news1 = new News(){ Category = CategoryEnum.Sports, Author = &quot;Leo&quot;, Title = &quot;2021東京奧運&quot; }; News news2 = new News() { Category = CategoryEnum.Politics, Author = &quot;Jerry&quot;, Title = &quot;莫德納疫苗抵台&quot; }; newsCenter.AddNews(news1); newsCenter.AddNews(news2); } }} 拉模型與推模型拉模型 (pull-model)以上的範例我們可以得知，讀者只收到新聞中心通知說有新的新聞，但不知道新聞類型為何，收到通知後讀者需要去「拉」 newsList 才知道該新聞為何，所以此類型稱為拉模型 (pull-model)。 推模型 (push-model)如果只想在收到特定新聞類型時才做相對應的事情，可以在 NotifyObservers() 時多傳入一個參數，讓訂閱者根據傳入參數決定要做什麼事，這種傳入參數的方式即為推模型 (push-model)。Github 的範例即為以推模型做示範，並以 NotifyObservers(CategoryEnum category) 通知讀者新增的新聞類型為何。 完整程式碼請參考 結論觀察者模式解決了「主題」更新後通知多個「觀察者」，且因為使用介面解了「主題」及「觀察者」間的耦合，每個訂閱者可以在收到通知後決定後續的動作。簡單介紹了拉模型與推模型，決定該使用何者取決於使用情境。 參考OBSERVER 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐[Design Pattern] 觀察者模式 (Observer Pattern) 我也能夠辦報社","link":"/2021/07/12/Observer-Pattern/"},{"title":"[Design Pattern] Adapter 模式","text":"Wiki 上是這麼定義 Adapter 模式的: 將一個類別的介面轉接成使用者所期待的。一個適配使得因介面不相容而不能在一起工作的類別能在一起工作。 舉個例子，我有養狗，但是我喜歡的女生比較喜歡貓，為了吸引他的注意力，我決定把我的狗假扮成一隻貓。套用到 Adapter 模式，可以想像成是這樣: 我要把我的狗 (Adaptee)，藉由外觀的打扮 (Adapter)，變成一隻貓 (Target) 看看自己的狗先來看我們既有的狗類別，以及他既有的方法。 Dog.cs123456789101112131415161718/*Dog.cs*/using System;namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// Dog /// &lt;/summary&gt; public class Dog { /// &lt;summary&gt; /// 狗叫 /// &lt;/summary&gt; public void Bark() { Console.WriteLine(&quot;I'm a dog, bark&quot;); } }} 看看要假扮的貓再來定義貓的介面，要求不多，只要我的狗會學貓叫即可。 ICat.cs1234567891011121314/*ICat.cs*/namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// ICat /// &lt;/summary&gt; public interface ICat { /// &lt;summary&gt; /// 貓叫 /// &lt;/summary&gt; void Meow(); }} Adapter 模式先定義一個類別 CatAdapter ，其會繼承介面 ICat 並需要實作 ICat 的方法 。建構子參數為我們既有的狗類別。現在要實作方法 Meow()，實作內容我們使用 Dog 類別的方法 Bark()，讓人以為狗叫是貓叫。(現實中是有點強人所難…) CatAdapter.cs1234567891011121314151617181920212223242526272829/*CatAdapter.cs*/namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// CatAdapter /// &lt;/summary&gt; public class CatAdapter : ICat { /// &lt;summary&gt; /// Dog /// &lt;/summary&gt; private Dog _dog; /// &lt;summary&gt; /// CatAdapter /// &lt;/summary&gt; /// &lt;param name=&quot;dog&quot;&gt;&lt;/param&gt; public CatAdapter(Dog dog) { this._dog = dog; } /// &lt;summary&gt; /// 貓叫 /// &lt;/summary&gt; public void Meow() { this._dog.Bark(); } }} 類別形式的 Adapter 模式上一個 Adapter 模式，我們是用建構子注入的方式，將我們的狗類別放進 CatAdapter 類別，另一種方式是直接繼承 Dog 類別，這樣的好處是我只要建立一個 CatAdapterClassType 類別就好，壞處是其造成 Dog 類別與 CatAdapterClassType 類別的強耦合。 CatAdapterClassType.cs12345678910111213141516171819202122/*CatAdapterClassType*/using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace DemoCode.DesignPattern.Adapter{ /// &lt;summary&gt; /// CatAdapterClassType /// &lt;/summary&gt; public class CatAdapterClassType : Dog, ICat { /// &lt;summary&gt; /// 貓叫 /// &lt;/summary&gt; public void Meow() { this.Bark(); } }} 最後來看結果: Program.cs1234567891011class Program{ static void Main(string[] args) { CatAdapter catAdapter = new CatAdapter(new Dog()); catAdapter.Meow(); CatAdapterClassType catAdapterClassType = new CatAdapterClassType(); catAdapterClassType.Meow(); Console.Read(); }} 完整程式碼請參考 結論如果因為介面的改變，造成與既有的系統不相容時，可以使用 Adapter 模式，將其轉換為既有系統可使用的格式。 參考江湖走跳，轉接頭很重要! (Adapter 適配器模式)Design Pattern: Structural Patterns- Adapter Pattern (適配器模式)Adapter 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/09/04/Adapter-Pattern/"}],"tags":[{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"},{"name":"UnitTest","slug":"UnitTest","link":"/tags/UnitTest/"}],"categories":[{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"UnitTest","slug":"UnitTest","link":"/categories/UnitTest/"}]}