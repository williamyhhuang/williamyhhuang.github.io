{"pages":[{"title":"About me","text":"大部分的程式碼是以 C# 示範，若有問題請與我聯繫williamyhhuang@gmail.com","link":"/about/index.html"}],"posts":[{"title":"[Design Pattern] Strategy 模式","text":"上一篇有提到，Template Method Pattern 違反了 DIP 原則，在寫程式時最需要注意的就是耦合性，倘若程式之間的耦合性高，修改一個類別結果造成所有繼承他的類別都需要修改，這樣的維護成本太高，而 Strategy Pattern 提供了解法。接續上一篇的範例，我們使用 Strategy 模式再重寫一次，會分為以下幾個步驟： 定義料理的抽象介面 實作中式料理類別 實作料理類別 定義料理的抽象介面首先先定義一個介面 ICooking，可以想像一下，如果做中式料理跟西式料理，有什麼步驟是相同的，但是詳細實作方法卻是不同的。以我們之前的範例，我將 準備材料 跟 烹飪 這兩個方法抽成介面，另外，在做菜前一定會知道要做什麼料理，所以我把 料理名稱 這個變數也放在介面中，後續繼承 ICooking 介面的類別，則需要實作這幾個方法及宣告屬性： 12345678910111213141516171819202122232425/*ICooking.cs*/namespace DemoCode.DesignPattern.Strategy{ /// &lt;summary&gt; /// 烹飪步驟 /// &lt;/summary&gt; public interface ICooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; string DishName { get; set; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; void Prepare(); /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; void Cook(); }} 實作中式料理類別現在來實作中式料理，由於 ChineseDish 繼承了 ICooking，需要實作其方法，而料理名稱是在建立 ChineseDish 時注入。往後若要實作西式料理類別，則只要繼承 ICooking 並實作即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*ChineseDish.cs*/using System;using System.Collections.Generic;namespace DemoCode.DesignPattern.Strategy{ public class ChineseDish : ICooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; public string DishName { get; set; } /// &lt;summary&gt; /// 食材 /// &lt;/summary&gt; private List&lt;string&gt; _ingredients; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public ChineseDish(string dishName) { this.DishName = dishName; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; public void Prepare() { Console.WriteLine($&quot;今天要來做{this.DishName}&quot;); switch (this.DishName) { case &quot;辣炒牛肉空心菜&quot;: this._ingredients = new List&lt;string&gt; { &quot;辣椒&quot;, &quot;空心菜&quot;, &quot;牛肉&quot; }; break; } //// 洗菜 this.Clean(); //// 切菜 this.Cut(); Console.WriteLine(&quot;材料準備好了&quot;); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public void Cook() { Console.WriteLine(&quot;中式料理當然要用鍋炒，材料有:{0}&quot;, string.Join(&quot;，&quot;, this._ingredients)); Console.WriteLine(&quot;菜煮好了&quot;); } /// &lt;summary&gt; /// 洗菜 /// &lt;/summary&gt; private void Clean() { Console.WriteLine(&quot;菜洗好了&quot;); } /// &lt;summary&gt; /// 切菜 /// &lt;/summary&gt; private void Cut() { Console.WriteLine(&quot;菜切好了&quot;); } }} 實作料理類別接下來我們來實作料理類別 Cooking，你可以想像成這個類別是餐廳的內場，它可以製作中式料理或是西式料理，只管跟他點菜即可。另外像 SetDish 及 Done 這兩個方法，因為做任何料理都有這兩個步驟，且實作細節皆相同，所以我把它放在 Cooking 類別中並實作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Cooking.cs*/using System;namespace DemoCode.DesignPattern.Strategy{ public class Cooking { /// &lt;summary&gt; /// ICooking /// &lt;/summary&gt; private ICooking _cooking; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;cooking&quot;&gt;&lt;/param&gt; public Cooking(ICooking cooking) { this._cooking = cooking; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; public void Prepare() { this._cooking.Prepare(); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public void Cook() { this._cooking.Cook(); } /// &lt;summary&gt; /// 裝盤 /// &lt;/summary&gt; public void SetDish() { Console.WriteLine($&quot;{this._cooking.DishName}好了，可以上菜囉&quot;); } /// &lt;summary&gt; /// 完成 /// &lt;/summary&gt; public void Done() { Console.WriteLine(&quot;完成上菜，來整理廚房&quot;); this.CleanUp(); } /// &lt;summary&gt; /// 整理廚房 /// &lt;/summary&gt; private void CleanUp() { Console.WriteLine(&quot;廚房整理好了&quot;); } }} 最後來看結果： 12345678910111213141516171819namespace DemoCode{ class Program { static void Main(string[] args) { // 先定義要做中式料理，並注入料理名稱 var dish = new DesignPattern.Strategy.ChineseDish(&quot;辣炒牛肉空心菜&quot;); // 將 dish 注入至 Cooking 類別 var cook = new DesignPattern.Strategy.Cooking(dish); cook.Prepare(); cook.Cook(); cook.SetDish(); cook.Done(); } }} 輸出結果如下，跟我們在 Template Method Pattern 得到的結果一樣： 123456789今天要來做辣炒牛肉空心菜菜洗好了菜切好了材料準備好了中式料理當然要用鍋炒，材料有:辣椒，空心菜，牛肉菜煮好了辣炒牛肉空心菜好了，可以上菜囉完成上菜，來整理廚房廚房整理好了 完整程式碼請參考 結論Strategy Pattern 的好處在於可擴充性及靈活度，往後若需要製作印度料理或是法式料理，則只要建立一個繼承 ICooking 介面的類別，在要新增 Cooking 類別時再注入。 這兩種 Pattern 可以想像成你想開一間什麼料理都有的餐廳，若是使用 Template Method Pattern，你需要每個料理都建立一個攤位，然後依據你想要的料理去各別的攤位點餐；而 Strategy Pattern 就好比你只需要跟中央廚房說你要什麼料理，無需東奔西跑。 參考TEMPLATE METHOD 模式和 STRATEGY 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/02/12/Strategy-Pattern/"},{"title":"[Design Pattern] Template Method 模式","text":"Template Method Pattern，顧名思義它就是一個模板，必須要在它指定的框架內完成實作。 所以要使用 Template Method Pattern，可以分為幾個步驟： 定義父類別抽象類型，也就是定義框架 子類別類型繼承父類別 子類別類型實作父類別的抽象方法 定義父類別抽象類型讓我們以「烹飪」當作範例，首先要定義烹飪會需要完成哪些步驟： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Cooking.cs*/using System;namespace TemplateMethodPattern{ /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public abstract class Cooking { /// &lt;summary&gt; /// 料理名稱 /// &lt;/summary&gt; public string _dishName; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public Cooking(string dishName) { this._dishName = dishName; } /// &lt;summary&gt; /// 準備材料 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public abstract void Prepare(); /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public abstract void Cook(); /// &lt;summary&gt; /// 裝盤 /// &lt;/summary&gt; public void SetDish() { Console.WriteLine($&quot;{this._dishName}好了，可以上菜囉&quot;); } /// &lt;summary&gt; /// 完成 /// &lt;/summary&gt; public void Done() { Console.WriteLine(&quot;完成上菜，來整理廚房&quot;); this.CleanUp(); } /// &lt;summary&gt; /// 整理廚房 /// &lt;/summary&gt; private void CleanUp() { Console.WriteLine(&quot;廚房整理好了&quot;); } }} 實作父類別的抽象方法今天要做一道辣炒牛肉空心菜，我們建立一個子類別中式料理 ChineseDish，繼承父類別，並實作父類別的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*ChineseDish.cs*/using System;using System.Collections.Generic;namespace TemplateMethodPattern{ /// &lt;summary&gt; /// 中式料理 /// &lt;/summary&gt; public class ChineseDish : Cooking { /// &lt;summary&gt; /// 食材 /// &lt;/summary&gt; private List&lt;string&gt; _ingredients; /// &lt;summary&gt; /// 建構子 /// &lt;/summary&gt; /// &lt;param name=&quot;dishName&quot;&gt;&lt;/param&gt; public ChineseDish(string dishName) : base(dishName) { } //// 準備材料 public override void Prepare() { Console.WriteLine($&quot;今天要來做{this._dishName}&quot;); switch (this._dishName) { case &quot;辣炒牛肉空心菜&quot;: this._ingredients = new List&lt;string&gt; { &quot;辣椒&quot;, &quot;空心菜&quot;, &quot;牛肉&quot; }; break; } //// 洗菜 this.Clean(); //// 切菜 this.Cut(); Console.WriteLine(&quot;材料準備好了&quot;); } /// &lt;summary&gt; /// 烹飪 /// &lt;/summary&gt; public override void Cook() { Console.WriteLine(&quot;中式料理當然要用鍋炒，材料有:{0}&quot;, string.Join(&quot;，&quot;, this._ingredients)); Console.WriteLine(&quot;菜煮好了&quot;); } /// &lt;summary&gt; /// 洗菜 /// &lt;/summary&gt; private void Clean() { Console.WriteLine(&quot;菜洗好了&quot;); } /// &lt;summary&gt; /// 切菜 /// &lt;/summary&gt; private void Cut() { Console.WriteLine(&quot;菜切好了&quot;); } }} 最後來看看結果： 1234567891011121314151617181920/*Program.cs*/using System;using System.Collections.Generic;namespace TemplateMethodPattern{ class Program { static void Main(string[] args) { var dish = new ChineseDish(&quot;辣炒牛肉空心菜&quot;); dish.Prepare(); dish.Cook(); dish.SetDish(); dish.Done(); } }} 輸出結果如下： 123456789今天要來做辣炒牛肉空心菜菜洗好了菜切好了材料準備好了中式料理當然要用鍋炒，材料有:辣椒，空心菜，牛肉菜煮好了辣炒牛肉空心菜好了，可以上菜囉完成上菜，來整理廚房廚房整理好了 完整程式碼請參考 結論這樣就完成了我們的中式料理，也可以用相同的方式做其他類型的料理。你可以想像成 Template Method Pattern 就像是你看著食譜做菜，只要照著“食譜”這個框架完成即可。不過 Template Method Pattern 是一種強烈的繼承關係，違反了 DIP 原則：高層模組不應該相依於低層模組，兩者都應該相依於抽象。下一篇介紹的 Strategy Design Pattern 解決了這個問題。 參考TEMPLATE METHOD 模式和 STRATEGY 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐Wiki - Template method pattern樣板方法模式","link":"/2021/02/11/Template-Method-Pattern/"},{"title":"[Design Pattern] Factory 模式","text":"假設我們今天要開一間玩具工廠，工廠生產的玩具有：金剛、哥吉拉，寫法可能像這樣： Program.cs12345678910111213141516171819/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;namespace DemoCode{ class Program { static void Main(string[] args) { IToy toy1 = new Gozilla(); IToy toy2 = new KingKong(); Console.WriteLine($&quot;Toy I made: {toy1.ToyName}&quot;); Console.WriteLine($&quot;Toy I made: {toy2.ToyName}&quot;); } }} IToy.cs123456789/*IToy.cs*/namespace DemoCode.DesignPattern.Factory{ public interface IToy { public string ToyName { get; set; } }} Gozilla.cs1234567891011121314/*Gozilla.cs*/namespace DemoCode.DesignPattern.Factory{ public class Gozilla : IToy { public string ToyName { get; set; } public Gozilla() { ToyName = &quot;Gozilla&quot;; } }} KingKong.cs1234567891011121314/*KingKong.cs*/namespace DemoCode.DesignPattern.Factory{ public class KingKong : IToy { public string ToyName { get; set; } public KingKong() { ToyName = &quot;KingKong&quot;; } }} 架構圖會像是這樣子，我們會在 Program 裡直接建立 KingKong、Gozilla 執行個體，如果這個類別不常變更，其實直接建立是沒有問題的，但如果是在開發階段，我們應當依賴於抽象介面，避免受類別變化帶來的影響。\b\b Factory 模式示範DIP 原則告訴我們：應該優先依賴於抽象類別，避免依賴於實體類別。所以我們新增一個工廠介面 IFactory，以及實作該介面的類別 Factory，藉由這個工廠來幫我們生產玩具： Program.cs123456789101112131415161718192021/*Program.cs*/using System;using DemoCode.DesignPattern.Factory;namespace DemoCode{ class Program { static void Main(string[] args) { IFactory factory = new Factory(); IToy toy1 = factory.Make(&quot;KingKong&quot;); IToy toy2 = factory.Make(&quot;Gozilla&quot;); Console.WriteLine($&quot;Toy I made is: {toy1.ToyName}&quot;); Console.WriteLine($&quot;Toy I made is: {toy2.ToyName}&quot;); } }} IFactory.cs123456789/*IFactory.cs*/namespace DemoCode.DesignPattern.Factory{ public interface IFactory { IToy Make(string toyName); }} Factory.cs123456789101112131415161718192021222324252627/*Factory.cs*/using System;namespace DemoCode.DesignPattern.Factory{ public class Factory : IFactory { public Factory() { } public IToy Make(string toyName) { switch (toyName) { case &quot;Gozilla&quot;: return new Gozilla(); case &quot;KingKong&quot;: return new KingKong(); default: throw new ApplicationException($&quot;沒有生產該玩具: {toyName}&quot;); } } }} 我們在 Program 中建立一個 Factory 的類別實作，並將製作玩具的工作交給 Factory，這樣的話職責就很明確，工廠專職製造玩具，Program 只需直接使用 Factory 所回傳的類別實作。 完整程式碼請參考 結論Factory 模式使得高層模組不依賴於類別的實作，並遵守 DIP 原則，在程式的職責管理上也較為清楚明白。但如果你的類別是不常變更且穩定的，那也不需使用 Factory 模式，直接建立類別實作會省事許多。 參考Factory 模式．無瑕的程式碼 敏捷完整篇：物件導向原則、設計模式與 C# 實踐","link":"/2021/04/04/Factory-Pattern/"}],"tags":[{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"}],"categories":[{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"}]}